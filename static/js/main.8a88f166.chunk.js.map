{"version":3,"sources":["components/button.tsx","components/page.tsx","pages/home/home.tsx","interfaces/game.interfaces.ts","components/result.tsx","hooks/useBoardGame.ts","pages/gomoku/canvasUtils.ts","pages/gomoku/board.tsx","algorithms/negmax.ts","pages/gomoku/gomoku.tsx","pages/tic-tac-toe/board.tsx","algorithms/minmax.ts","pages/tic-tac-toe/tic-tac-toe.tsx","App.tsx","index.tsx"],"names":["ButtonWrapper","styled","button","_templateObject","_taggedTemplateLiteral","Button","_ref","children","onClick","delay","active","setActive","useState","ref","useRef","onClickWithAnimation","useCallback","_ref$current","current","focus","setTimeout","_ref$current2","blur","React","createElement","Page","main","sample","Title","h1","About","div","_templateObject2","HomePage","navigate","useNavigate","style","gap","target","href","rel","CellStatus","GameStatus","ResultWrapper","Result","forwardRef","_","status","setStatus","OnGoing","text","useMemo","Player1Won","Player2Won","useImperativeHandle","show","hide","opacity","check","bitmap","row","column","winningCount","arrays","i","push","Array","fill","map","j","temp","x","y","results","arr","length","Blank","slice","every","console","debug","Player1","checkRow","filter","some","c","Tie","useBoardGame","firstHand","seq","setSeq","moves","setMoves","player","setPlayer","placeChess","pre","Player2","ret","forEach","gameStatus","restart","HEIGHT","window","innerHeight","WIDTH","innerWidth","BOARD_SIZE","RATE","Math","round","OFFSET","ceil","RADIUS","init","canvas","error","width","height","ctx","getContext","strokeStyle","lineWidth","moveTo","lineTo","stroke","draw","turn","x1","y1","fillStyle","beginPath","arc","PI","closePath","font","concat","x2","y2","fillText","Board","onStatusChange","onPlayerPlaced","canvasRef","enable","useLayoutEffect","useEffect","e","cx","clientX","cy","clientY","click2Coordinates","negamax","board","depth","color","alpha","beta","bestMove","score","Infinity","isGameOver","evaluateBoard","generateMoves","move","nextMove","max","hasAdjacent","sort","a","b","evaluateMove","directions","dx","dy","nx","ny","evaluateLines","transpose","evaluateDiagonals","colIndex","evaluateLine","size","majorDiagonal","minorDiagonal","line","segment","evaluateSegment","countX","cell","countO","checkWinningCondition","checkDirection","startX","startY","deltaX","deltaY","count","ActionBar","section","GomokuPage","boardRef","resultRef","_resultRef$current","log","_resultRef$current2","_resultRef$current3","res","findBestMove","_boardRef$current","_resultRef$current4","onClickRestart","_boardRef$current2","_resultRef$current5","EmptyCell","td","Player1Cell","Player2Cell","_templateObject3","Cell","Table","table","_templateObject4","_ref2","r","key","SIZE","minimax","isMaximizing","col","evaluate","isMovesLeft","bestScore","min","TicTacToePage","router","createHashRouter","path","element","App","RouterProvider","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.8a88f166.chunk.js","sourcesContent":["import React, { PropsWithChildren, useCallback, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nconst ButtonWrapper = styled.button`\n    all:  unset;\n    min-width: 140px;\n    text-align: center;\n    color: #333;\n    text-decoration: none;\n    text-transform: uppercase;\n    letter-spacing: 2.8px;\n    background-color:  #fff;\n    padding: 15px 50px;\n    border-radius: 5rem;\n    box-shadow:  1px 2.9px 16px #aaa;\n    transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n    cursor: pointer;\n\n    &:hover {\n        box-shadow: 3px 4.9px 16px #aaa;\n        letter-spacing:  5px\n    }\n\n    &:focus {\n        transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n        padding: 15px 2px;\n        width: 100vw;\n        height: 100vh;\n        position: fixed;\n        top: 0;\n        left: 0;\n        text-align: center;\n        font-size: 5rem;\n        border-radius: 0%;\n    }\n`;\n\nexport interface IButtonProps {\n    onClick?: () => void;\n    /**\n     * If set true, the `onClick` will be trigger after animation\n     */\n    delay?: boolean;\n}\n\nexport const Button = ({\n    children,\n    onClick = () => {},\n    delay = false,\n}: PropsWithChildren<IButtonProps>) => {\n    const [active, setActive] = useState<boolean>(false);\n    const ref = useRef<HTMLButtonElement>(null);\n\n    const onClickWithAnimation = useCallback(() => {\n        if (active) return;\n\n        if (!delay) onClick();\n\n        setActive(true);\n        ref.current?.focus();\n        setTimeout(() => {\n            setActive(false);\n            ref.current?.blur();\n            if (delay) onClick();\n        }, 700);\n    }, [onClick, delay, active]);\n\n    return (\n        <ButtonWrapper ref={ref} onClick={onClickWithAnimation}>\n            {children}\n        </ButtonWrapper>\n    );\n};","import React from \"react\";\nimport sample from \"lodash/sample\";\nimport styled from \"styled-components\";\n\nconst COLOR_LIST = ['#606470', '#3c79ce', '#F9CE00', '#4CAF50', '#FF9800'];\n\nexport const Page = styled.main`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: ${sample(COLOR_LIST)};\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n","import React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Button } from \"../../components/button\";\nimport { Page } from \"../../components/page\";\nimport styled from \"styled-components\";\n\nconst Title = styled.h1`\n    color: #fff;\n    font-size: 6em;\n`;\n\nconst About = styled.div`\n    position: absolute;\n    bottom: 40px;\n    & a {\n        all: unset;\n        cursor: pointer;\n        text-decoration: underline;\n        color: #fff;\n    }\n`;\n\nexport const HomePage = () => {\n    const navigate = useNavigate();\n\n    return (\n        <Page style={{ gap: 20 }}>\n            <Title>Games</Title>\n            <Button onClick={() => navigate(\"/tic-tac-toe\")} delay={true}>Tic Tac Toe</Button>\n            <Button onClick={() => navigate(\"/gomoku\")} delay={true}>Gomoku</Button>\n            <About>\n                <a target=\"_blank\" href=\"https://github.com/keyi6/ai-games/\" rel=\"noopener noreferrer\">https://github.com/keyi6/ai-games/</a>\n            </About>\n        </Page>\n    );\n};\n","export enum CellStatus {\n    Blank = 0,\n    Player1 = 1,\n    Player2 = -1,\n}\n\nexport enum GameStatus {\n    OnGoing,\n    Tie = \"tie\",\n    Player1Won = \"player 1\",\n    Player2Won = \"player 2\",\n}\n\nexport interface IMove {\n    x: number;\n    y: number;\n    status: CellStatus;\n    seq: number;\n}\n\nexport interface Move {\n    x: number;\n    y: number;\n    score: number;\n};","import React, { forwardRef, useImperativeHandle, useMemo, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { GameStatus } from \"../interfaces/game.interfaces\";\n\nexport const ResultWrapper = styled.div`\n    position: absolute;\n    text-decoration: none;\n    text-transform: uppercase;\n    top: 0;\n    left: 0;\n    color: #333;\n    background-color: #fff;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    font-size: 6rem;\n    height: 100vh;\n    width: 100vw;\n    z-index: 999;\n    text-align: center;\n`;\n\nexport interface IResultRef {\n    show: (status: GameStatus | \"loading\") => void;\n    hide: () => void;\n}\n\nexport const Result = forwardRef<IResultRef>((_, ref) => {\n    const [active, setActive] = useState<boolean>(false);\n    const [status, setStatus] = useState<GameStatus | \"loading\">(GameStatus.OnGoing);\n    const text = useMemo(() => {\n        if (status === \"loading\") return \"Calculating...\";\n        if (status === GameStatus.Player1Won) return \"You won\";\n        if (status === GameStatus.Player2Won) return \"You lost\";\n        return \"Tie\";\n    }, [status]);\n\n    useImperativeHandle(ref, (): IResultRef => ({\n        show: (status) => {\n            setStatus(status);\n            setActive(true);\n        },\n\n        hide: () => {\n            setActive(false);\n        },\n    }));\n    \n    if (!active) return null;\n    return (\n        <ResultWrapper style={{ opacity: status === \"loading\" ? 0.1 : 0.8 }}>\n            {text}\n        </ResultWrapper>\n    );\n});\n","import { useState, useCallback, useMemo } from \"react\";\nimport { GameStatus, IMove, CellStatus } from \"../interfaces/game.interfaces\";\n\nfunction checkRow(arr: CellStatus[], winningCount: number): GameStatus {\n    if (arr.length < winningCount) return GameStatus.OnGoing;\n    for (let i = 0; i + winningCount <= arr.length; i ++) {\n        if (arr[i] === CellStatus.Blank) continue;\n\n        if (arr.slice(i + 1, i + winningCount).every(x => x === arr[i])) {\n            console.debug(\"Matched\", arr);\n            return arr[i] === CellStatus.Player1\n                ? GameStatus.Player1Won\n                : GameStatus.Player2Won;\n        }\n    }\n\n    return GameStatus.OnGoing;\n}\n\nexport function check(\n    bitmap: CellStatus[][],\n    row: number,\n    column: number,\n    winningCount: number,\n): GameStatus {\n    // add rows\n    const arrays: CellStatus[][] = [...bitmap];\n\n    // add columns\n    for (let i = 0; i < column; i ++) {\n        arrays.push(new Array(row)\n            .fill(0)\n            .map((_, j) => bitmap[j][i]));\n    }\n\n    for (let i = 0; i < column; i ++) {\n        let temp = [];\n        let x = 0, y = i;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = 0; y = i;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    for (let i = 0; i < row; i ++) {\n        let temp = [];\n        let x = i, y = 0;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = i; y = 0;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    const results = arrays\n        .map(arr => checkRow(arr, winningCount))\n        .filter(x => x !== GameStatus.OnGoing);\n    if (results.length) return results[0];\n\n    if (bitmap.some(row => row.some(c => c === CellStatus.Blank))) return GameStatus.OnGoing;\n    return GameStatus.Tie;\n}\n\n\nexport function useBoardGame(row: number, column: number, winningCount: number, firstHand: boolean) {\n    const [seq, setSeq] = useState<number>(0);\n    const [moves, setMoves] = useState<IMove[]>([]);\n    // true -> player 1 is going to place next chess; false -> player 2\n    const [player, setPlayer] = useState<boolean>(firstHand);\n\n    const placeChess = useCallback((x: number, y: number) => {\n        setMoves(pre => [...pre, {\n            x, y, seq,\n            status: player ? CellStatus.Player1 : CellStatus.Player2,\n        }]);\n        setSeq(pre => pre + 1);\n        setPlayer(pre => !pre);\n\n        return moves;\n    }, [seq, player]);\n\n    const bitmap = useMemo<CellStatus[][]>(() => {\n        const ret = new Array(row)\n            .fill(0)\n            .map(_ => new Array(column).fill(CellStatus.Blank));\n        moves.forEach(({ x, y, status }) => ret[x][y] = status);\n        return ret;\n    }, [moves, column, row]);\n\n    const gameStatus = useMemo<GameStatus>(\n        () => check(bitmap, row, column, winningCount),\n        [bitmap, row, column, winningCount],\n    );\n\n    const restart = useCallback(() => {\n        setSeq(0);\n        setMoves([]);\n        setPlayer(firstHand);\n    }, [firstHand]);\n\n    return { bitmap, placeChess, gameStatus, player, restart, seq };\n}\n","import React from \"react\";\n\n\nconst HEIGHT = window.innerHeight;\nconst WIDTH = window.innerWidth;\nconst BASE = HEIGHT < WIDTH ? HEIGHT : WIDTH;\nconst BOARD_SIZE = BASE * 0.6;\n\nconst RATE = Math.round(BOARD_SIZE / 15);\nconst OFFSET = Math.ceil((BOARD_SIZE - RATE * 14) * 0.5);\nconst RADIUS = RATE * 0.4;\n\n\nexport function init(canvas: HTMLCanvasElement | null) {\n    if (!canvas) {\n        console.error(\"Canvas is null\");\n        return;\n    }\n\n    canvas.width = BOARD_SIZE;\n    canvas.height = BOARD_SIZE;\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    for (let i = 0; i < 15; i++) {\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(OFFSET + i * RATE, OFFSET);\n        ctx.lineTo(OFFSET + i * RATE, BOARD_SIZE - OFFSET);\n        ctx.stroke();\n\n        ctx.moveTo(OFFSET, i * RATE + OFFSET);\n        ctx.lineTo(BOARD_SIZE - OFFSET, i * RATE + OFFSET);\n        ctx.stroke();\n    }\n}\n\nexport function draw(canvas: HTMLCanvasElement | null, x: number, y: number, turn: number) {\n    const ctx = canvas?.getContext('2d');\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    const x1 = x * RATE + OFFSET;\n    const y1 = y * RATE + OFFSET;\n\n    ctx.fillStyle = turn % 2 === 0 ? \"#000\" : \"#fff\";\n\n    ctx.beginPath();\n    ctx.arc(x1, y1, RADIUS, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = turn % 2 === 0 ? \" #fff\" : \" #000\";\n    ctx.font=\"20px sans-serif\";\n    const text = `${turn + 1}`;\n    const x2 = x1 - text.length * 10 + 8;\n    const y2 = y1 + 5;\n    ctx.fillText(text, x2, y2);\n};\n\n\nexport function click2Coordinates(e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n    const cx = e.clientX - OFFSET - (window.innerWidth- BOARD_SIZE) / 2;\n    const cy = e.clientY - OFFSET - (window.innerHeight- BOARD_SIZE) / 2;\n\n    const x = Math.round(cx / RATE), y = Math.round(cy / RATE);\n    return { x, y };\n}","import React, {\n    forwardRef, useCallback, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport { click2Coordinates, draw, init } from \"./canvasUtils\";\n\nconst ROW = 15;\nconst COL = 15;\nconst WINNING_COUNT = 5;\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const {\n        bitmap, placeChess, gameStatus, player, restart, seq\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        },\n        restart: () => {\n            restart();\n            init(canvasRef.current);\n        }\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap]);\n\n    useEffect(() => {\n        init(canvasRef.current);\n    }, []);\n\n    const onClick = useCallback((e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n        if (!enable) return;\n\n        const { x, y } = click2Coordinates(e);\n\n        if (bitmap[x][y] === CellStatus.Blank) {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        }\n    }, [seq, bitmap]);\n\n    return (\n        <div>\n            <canvas ref={canvasRef}\n                onClick={onClick}\n            />\n\n        </div>\n    );\n});\n","import { Move } from \"../interfaces/game.interfaces\";\n\nexport function findBestMove(board: number[][]): Move {\n    return negamax(board, 2, -1, -Infinity, Infinity);\n}\n\n\nexport const negamax = (\n    board: number[][],\n    depth: number,\n    color: number,\n    alpha: number,\n    beta: number\n): Move => {\n    let bestMove: Move = { x: -1, y: -1, score: -Infinity };\n\n    if (depth === 0 || isGameOver(board)) {\n        return { x: -1, y: -1, score: color * evaluateBoard(board) };\n    }\n\n    let moves = generateMoves(board);\n\n    for (let move of moves) {\n        board[move.x][move.y] = color;\n\n        const nextMove = negamax(board, depth - 1, -color, -beta, -alpha);\n        nextMove.score = -nextMove.score;\n\n        board[move.x][move.y] = 0; // Undo the move\n\n        if (nextMove.score > bestMove.score) {\n            bestMove = { x: move.x, y: move.y, score: nextMove.score };\n        }\n\n        alpha = Math.max(alpha, nextMove.score);\n        if (alpha >= beta) {\n            break; // Beta cutoff\n        }\n    }\n\n    return bestMove;\n};\n\n\n// Generate possible moves, ordered by proximity to the last moves\nconst generateMoves = (board: number[][]): Move[] => {\n    let moves: Move[] = [];\n\n    for (let x = 0; x < board.length; x++) {\n        for (let y = 0; y < board[x].length; y++) {\n            if (board[x][y] === 0 && hasAdjacent(board, x, y)) {\n                moves.push({ x, y, score: 0 });\n            }\n        }\n    }\n\n    // Optionally, sort moves by heuristic score to improve pruning\n    moves.sort((a, b) => evaluateMove(board, b) - evaluateMove(board, a));\n\n    return moves;\n};\n\n// Check if a move is adjacent to any occupied cell\nconst hasAdjacent = (board: number[][], x: number, y: number): boolean => {\n    const directions = [\n        [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, -1], [1, -1], [-1, 1]\n    ];\n\n    for (let [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < board.length && ny >= 0 && ny < board.length && board[nx][ny] !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// Heuristically evaluate a move\nconst evaluateMove = (board: number[][], move: Move): number => {\n    board[move.x][move.y] = 1; // Assume the AI plays here\n    const score = evaluateBoard(board);\n    board[move.x][move.y] = 0; // Undo the move\n    return score;\n};\n\nconst evaluateBoard = (board: number[][]): number => {\n    let score = 0;\n\n    // Check rows, columns, and diagonals for potential scores\n    score += evaluateLines(board);\n    score += evaluateLines(transpose(board));\n    score += evaluateDiagonals(board);\n    score += evaluateDiagonals(transpose(board));\n\n    return score;\n};\n\n// Helper function to transpose the board (rows become columns)\nconst transpose = (board: number[][]): number[][] => {\n    return board[0].map((_, colIndex) => board.map(row => row[colIndex]));\n};\n\n// Evaluate rows and columns\nconst evaluateLines = (board: number[][]): number => {\n    let score = 0;\n\n    for (let row of board) {\n        score += evaluateLine(row);\n    }\n\n    return score;\n};\n\n// Evaluate diagonals (both major and minor)\nconst evaluateDiagonals = (board: number[][]): number => {\n    let score = 0;\n    const size = board.length;\n\n    // Major diagonals\n    for (let i = -size + 1; i < size; i++) {\n        let majorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = x + i;\n            if (y >= 0 && y < size) {\n                majorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(majorDiagonal);\n    }\n\n    // Minor diagonals\n    for (let i = 0; i < 2 * size - 1; i++) {\n        let minorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = i - x;\n            if (y >= 0 && y < size) {\n                minorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(minorDiagonal);\n    }\n\n    return score;\n};\n\n// Evaluate a single line (row, column, or diagonal)\nconst evaluateLine = (line: number[]): number => {\n    let score = 0;\n\n    for (let i = 0; i < line.length - 4; i++) {\n        const segment = line.slice(i, i + 5);\n        score += evaluateSegment(segment);\n    }\n\n    return score;\n};\n\n// Evaluate a segment of 5 cells\nconst evaluateSegment = (segment: number[]): number => {\n    const countX = segment.filter(cell => cell === 1).length;\n    const countO = segment.filter(cell => cell === -1).length;\n\n    if (countX === 5) return 100000; // Win for X\n    if (countO === 5) return -100000; // Win for O\n    if (countX > 0 && countO > 0) return 0; // Blocked line\n    if (countX === 4) return 1000;\n    if (countO === 4) return -1000;\n    if (countX === 3) return 100;\n    if (countO === 3) return -100;\n    if (countX === 2) return 10;\n    if (countO === 2) return -10;\n\n    return 0;\n};\n\nconst isGameOver = (board: number[][]): boolean => {\n    return checkWinningCondition(board, 1) || checkWinningCondition(board, -1);\n};\n\n// Check if a player has won\nconst checkWinningCondition = (board: number[][], player: number): boolean => {\n    const size = board.length;\n\n    // Check rows, columns, and diagonals\n    for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n            if (\n                checkDirection(board, x, y, player, 1, 0) || // Check row\n                checkDirection(board, x, y, player, 0, 1) || // Check column\n            checkDirection(board, x, y, player, 1, 1) || // Check major diagonal\n        checkDirection(board, x, y, player, 1, -1)   // Check minor diagonal\n            ) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// Check a direction (e.g., row, column, diagonal) for a win\nfunction checkDirection(\n    board: number[][],\n    startX: number,\n    startY: number,\n    player: number,\n    deltaX: number,\n    deltaY: number\n): boolean {\n    const size = board.length;\n    let count = 0;\n\n    for (let i = 0; i < 5; i++) {\n        const x = startX + i * deltaX;\n        const y = startY + i * deltaY;\n\n        if (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === player) {\n            count++;\n        } else {\n            break;\n        }\n\n        if (count === 5) {\n            return true;\n        }\n    }\n\n    return false;\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { Button } from \"../../components/button\";\nimport { IResultRef, Result } from \"../../components/result\";\nimport { Board, IBoardRef } from \"./board\";\nimport { findBestMove } from \"../../algorithms/negmax\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\n\nexport const GomokuPage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 200);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        resultRef.current?.show(\"loading\");\n\n        const res = findBestMove(board);\n        console.log(res);\n        setTimeout(() => {\n            boardRef.current?.placeChess(res.x, res.y);\n            resultRef.current?.hide();\n        }, 500);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React, {\n    FunctionComponent, forwardRef, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef,\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport styled from \"styled-components\";\n\nconst ROW = 3;\nconst COL = 3;\nconst WINNING_COUNT = 3;\nconst SIZE = 20;\n\nconst EmptyCell = styled.td`\n    height: ${SIZE}vmin;\n    width: ${SIZE}vmin;\n    font-size: calc(${SIZE}vmin - 20px);\n    line-height: calc(${SIZE}vmin - 20px);\n    cursor: pointer;\n    text-align: center;\n`;\n\nconst Player1Cell = styled(EmptyCell)`\n    &:after {\n        content: \"⭕️\";\n    }\n`;\n\nconst Player2Cell = styled(EmptyCell)`\n    &:after {\n        content: \"❌\";\n    }\n`;\n\nconst Cell: FunctionComponent<{\n    status: CellStatus;\n    onClick: () => void;\n}> = ({ status, onClick }) => {\n    if (status === CellStatus.Blank) return <EmptyCell onClick={onClick} />\n\n    return status === CellStatus.Player1\n        ? <Player1Cell />\n        : <Player2Cell />;\n};\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\nconst Table = styled.table`\n    border-collapse: collapse;\n\n    td + td,\n    th + th { border-left: 2vmin solid #fff; }\n    tr + tr { border-top: 2vmin solid #fff; }\n`;\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const boardRef = useRef(null);\n    const {\n        bitmap, placeChess, gameStatus, player, restart,\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    const board = useMemo(() => bitmap.map((r, x) => (\n        <tr key={`row-${x}`}>\n            {\n                r.map((c, y) => (\n                    <Cell key={`cell-${x}-${y}`}\n                        status={c}\n                        onClick={() => enable && placeChess(x, y)}\n                    />\n                ))\n            }\n        </tr>\n    )), [bitmap, placeChess, enable]);\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => placeChess(x, y),\n        restart: () => restart(),\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap, gameStatus, onPlayerPlaced]);\n\n    return (\n        <Table ref={boardRef}>\n            <tbody>\n                {board}\n            </tbody>\n        </Table>\n    );\n});\n","// Define the board size\nconst SIZE = 3;\n\nexport function findBestMove(board: number[][]): { x: number, y: number, score: number } {\n    let bestScore = -Infinity;\n    let bestMove = { x: -1, y: -1, score: bestScore };\n\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) {\n                board[i][j] = -1; // AI makes a move\n                const score = minimax(board, 0, false);\n                board[i][j] = 0; // Undo the move\n\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestMove = { x: i, y: j, score: bestScore };\n                }\n            }\n        }\n    }\n\n    return bestMove;\n}\n\n// Minimax function to evaluate the board\nfunction minimax(board: number[][], depth: number, isMaximizing: boolean): number {\n    let score = evaluate(board);\n\n    if (score === 10) return score - depth;\n    if (score === -10) return score + depth;\n    if (isMovesLeft(board) === false) return 0;\n\n    if (isMaximizing) {\n        let bestScore = -Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = -1; // AI makes a move\n                    bestScore = Math.max(bestScore, minimax(board, depth + 1, false));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    } else {\n        let bestScore = Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = 1; // Player makes a move\n                    bestScore = Math.min(bestScore, minimax(board, depth + 1, true));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    }\n}\n\nfunction evaluate(board: number[][]): number {\n    for (let row = 0; row < SIZE; row++) {\n        if (board[row][0] === board[row][1] && board[row][1] === board[row][2]) {\n            if (board[row][0] === -1) return 10;\n            else if (board[row][0] === 1) return -10;\n        }\n    }\n\n    for (let col = 0; col < SIZE; col++) {\n        if (board[0][col] === board[1][col] && board[1][col] === board[2][col]) {\n            if (board[0][col] === -1) return 10;\n            else if (board[0][col] === 1) return -10;\n        }\n    }\n\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        if (board[0][0] === -1) return 10;\n        else if (board[0][0] === 1) return -10;\n    }\n\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        if (board[0][2] === -1) return 10;\n        else if (board[0][2] === 1) return -10;\n    }\n\n    return 0;\n}\n\n// Function to check if there are any moves left\nfunction isMovesLeft(board: number[][]): boolean {\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) return true;\n        }\n    }\n    return false;\n}\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { Board, IBoardRef } from \"./board\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { findBestMove } from \"../../algorithms/minmax\";\nimport { Button } from \"../../components/button\";\nimport styled from \"styled-components\";\nimport { IResultRef, Result } from \"../../components/result\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\nexport const TicTacToePage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 400);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        const res = findBestMove(board);\n\n        boardRef.current?.placeChess(res.x, res.y);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React from 'react';\nimport { createHashRouter, RouterProvider } from \"react-router-dom\";\nimport { HomePage, TicTacToePage, GomokuPage } from './pages';\nimport './App.css';\n\nconst router = createHashRouter([\n    {\n        path: \"/tic-tac-toe\",\n        element: <TicTacToePage />,\n    },\n    {\n        path: \"/gomoku\",\n        element: <GomokuPage />\n    },\n    {\n        path: \"/\",\n        element: <HomePage />\n    },\n]);\n\nexport const App = () => {\n    return (\n        <RouterProvider router={router} />\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport { App } from './App';\n\nconst root = ReactDOM.createRoot(\n    document.getElementById('root') as HTMLElement\n);\n\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n"],"sourceRoot":""}
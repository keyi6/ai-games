{"version":3,"sources":["components/button.tsx","components/page.tsx","pages/home/home.tsx","interfaces/game.interfaces.ts","components/result.tsx","hooks/useBoardGame.ts","pages/gomoku/canvasUtils.ts","pages/gomoku/board.tsx","algorithms/negmax.ts","pages/gomoku/gomoku.tsx","pages/tic-tac-toe/board.tsx","algorithms/minmax.ts","pages/tic-tac-toe/tic-tac-toe.tsx","App.tsx","index.tsx"],"names":["ButtonWrapper","styled","button","_templateObject","_taggedTemplateLiteral","Button","_ref","children","onClick","delay","active","setActive","useState","ref","useRef","onClickWithAnimation","useCallback","_ref$current","current","focus","setTimeout","_ref$current2","blur","React","createElement","Page","main","sample","Title","h1","About","div","_templateObject2","HomePage","navigate","useNavigate","style","gap","target","href","rel","CellStatus","GameStatus","ResultWrapper","Result","forwardRef","_","status","setStatus","OnGoing","text","useMemo","Player1Won","Player2Won","useImperativeHandle","show","hide","opacity","check","bitmap","row","column","winningCount","arrays","i","push","Array","fill","map","j","temp","x","y","results","arr","length","Blank","slice","every","console","debug","Player1","checkRow","filter","some","c","Tie","useBoardGame","firstHand","seq","setSeq","moves","setMoves","player","setPlayer","placeChess","pre","Player2","ret","forEach","error","concat","log","gameStatus","restart","HEIGHT","window","innerHeight","WIDTH","innerWidth","BOARD_SIZE","RATE","Math","round","OFFSET","ceil","RADIUS","init","canvas","width","height","ctx","getContext","strokeStyle","lineWidth","moveTo","lineTo","stroke","draw","turn","x1","y1","fillStyle","beginPath","arc","PI","closePath","font","x2","y2","fillText","client2Coordinate","e","cx","clientX","cy","clientY","coordinate2client","Preview","span","Highlight","Board","onStatusChange","onPlayerPlaced","highlightPos","setHighlightPos","canvasRef","enable","setPreviewPos","setHighlighPos","useLayoutEffect","useEffect","previewPos","showPreview","onMouseMove","top","left","negamax","board","depth","color","alpha","beta","bestMove","score","Infinity","isGameOver","evaluateBoard","generateMoves","move","nextMove","max","hasAdjacent","sort","a","b","evaluateMove","directions","dx","dy","nx","ny","evaluateLines","transpose","evaluateDiagonals","colIndex","evaluateLine","size","majorDiagonal","minorDiagonal","line","segment","evaluateSegment","countX","cell","countO","checkWinningCondition","checkDirection","startX","startY","deltaX","deltaY","count","ActionBar","section","GomokuPage","boardRef","resultRef","_resultRef$current","_resultRef$current2","_resultRef$current3","res","findBestMove","_boardRef$current","_boardRef$current2","_resultRef$current4","onClickRestart","_boardRef$current3","_resultRef$current5","EmptyCell","td","Player1Cell","Player2Cell","_templateObject3","Cell","Table","table","_templateObject4","_ref2","r","key","SIZE","minimax","isMaximizing","col","evaluate","isMovesLeft","bestScore","min","TicTacToePage","router","createHashRouter","path","element","App","RouterProvider","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.1a2e55ce.chunk.js","sourcesContent":["import React, { PropsWithChildren, useCallback, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nconst ButtonWrapper = styled.button`\n    all:  unset;\n    min-width: 140px;\n    text-align: center;\n    color: #333;\n    text-decoration: none;\n    text-transform: uppercase;\n    letter-spacing: 2.8px;\n    background-color:  #fff;\n    padding: 15px 50px;\n    border-radius: 5rem;\n    box-shadow:  1px 2.9px 16px #aaa;\n    transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n    cursor: pointer;\n\n    &:hover {\n        box-shadow: 3px 4.9px 16px #aaa;\n        letter-spacing:  5px\n    }\n\n    &:focus {\n        transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n        padding: 15px 2px;\n        width: 100vw;\n        height: 100vh;\n        position: fixed;\n        top: 0;\n        left: 0;\n        text-align: center;\n        font-size: 5rem;\n        border-radius: 0%;\n    }\n`;\n\nexport interface IButtonProps {\n    onClick?: () => void;\n    /**\n     * If set true, the `onClick` will be trigger after animation\n     */\n    delay?: boolean;\n}\n\nexport const Button = ({\n    children,\n    onClick = () => {},\n    delay = false,\n}: PropsWithChildren<IButtonProps>) => {\n    const [active, setActive] = useState<boolean>(false);\n    const ref = useRef<HTMLButtonElement>(null);\n\n    const onClickWithAnimation = useCallback(() => {\n        if (active) return;\n\n        if (!delay) onClick();\n\n        setActive(true);\n        ref.current?.focus();\n        setTimeout(() => {\n            setActive(false);\n            ref.current?.blur();\n            if (delay) onClick();\n        }, 700);\n    }, [onClick, delay, active]);\n\n    return (\n        <ButtonWrapper ref={ref} onClick={onClickWithAnimation}>\n            {children}\n        </ButtonWrapper>\n    );\n};","import React from \"react\";\nimport sample from \"lodash/sample\";\nimport styled from \"styled-components\";\n\nconst COLOR_LIST = ['#606470', '#3c79ce', '#F9CE00', '#4CAF50', '#FF9800'];\n\nexport const Page = styled.main`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: ${sample(COLOR_LIST)};\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n","import React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Button } from \"../../components/button\";\nimport { Page } from \"../../components/page\";\nimport styled from \"styled-components\";\n\nconst Title = styled.h1`\n    color: #fff;\n    font-size: 6em;\n`;\n\nconst About = styled.div`\n    position: absolute;\n    bottom: 40px;\n    & a {\n        all: unset;\n        cursor: pointer;\n        text-decoration: underline;\n        color: #fff;\n    }\n`;\n\nexport const HomePage = () => {\n    const navigate = useNavigate();\n\n    return (\n        <Page style={{ gap: 20 }}>\n            <Title>Games</Title>\n            <Button onClick={() => navigate(\"/tic-tac-toe\")} delay={true}>Tic Tac Toe</Button>\n            <Button onClick={() => navigate(\"/gomoku\")} delay={true}>Gomoku</Button>\n            <About>\n                <a target=\"_blank\" href=\"https://github.com/keyi6/ai-games/\" rel=\"noopener noreferrer\">https://github.com/keyi6/ai-games/</a>\n            </About>\n        </Page>\n    );\n};\n","export enum CellStatus {\n    Blank = 0,\n    Player1 = 1,\n    Player2 = -1,\n}\n\nexport enum GameStatus {\n    OnGoing,\n    Tie = \"tie\",\n    Player1Won = \"player 1\",\n    Player2Won = \"player 2\",\n}\n\nexport interface IMove {\n    x: number;\n    y: number;\n    status: CellStatus;\n    seq: number;\n}\n\nexport interface Move {\n    x: number;\n    y: number;\n    score: number;\n};","import React, { forwardRef, useImperativeHandle, useMemo, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { GameStatus } from \"../interfaces/game.interfaces\";\n\nexport const ResultWrapper = styled.div`\n    position: absolute;\n    text-decoration: none;\n    text-transform: uppercase;\n    top: 0;\n    left: 0;\n    color: #333;\n    background-color: #fff;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    font-size: 6rem;\n    height: 100vh;\n    width: 100vw;\n    z-index: 999;\n    text-align: center;\n`;\n\nexport interface IResultRef {\n    show: (status: GameStatus | \"loading\") => void;\n    hide: () => void;\n}\n\nexport const Result = forwardRef<IResultRef>((_, ref) => {\n    const [active, setActive] = useState<boolean>(false);\n    const [status, setStatus] = useState<GameStatus | \"loading\">(GameStatus.OnGoing);\n    const text = useMemo(() => {\n        if (status === \"loading\") return \"Calculating...\";\n        if (status === GameStatus.Player1Won) return \"You won\";\n        if (status === GameStatus.Player2Won) return \"You lost\";\n        return \"Tie\";\n    }, [status]);\n\n    useImperativeHandle(ref, (): IResultRef => ({\n        show: (status) => {\n            setStatus(status);\n            setActive(true);\n        },\n\n        hide: () => {\n            setActive(false);\n        },\n    }));\n    \n    if (!active) return null;\n    return (\n        <ResultWrapper style={{ opacity: status === \"loading\" ? 0.1 : 0.8 }}>\n            {text}\n        </ResultWrapper>\n    );\n});\n","import { useState, useCallback, useMemo } from \"react\";\nimport { GameStatus, IMove, CellStatus } from \"../interfaces/game.interfaces\";\n\nfunction checkRow(arr: CellStatus[], winningCount: number): GameStatus {\n    if (arr.length < winningCount) return GameStatus.OnGoing;\n    for (let i = 0; i + winningCount <= arr.length; i ++) {\n        if (arr[i] === CellStatus.Blank) continue;\n\n        if (arr.slice(i + 1, i + winningCount).every(x => x === arr[i])) {\n            console.debug(\"Matched\", arr);\n            return arr[i] === CellStatus.Player1\n                ? GameStatus.Player1Won\n                : GameStatus.Player2Won;\n        }\n    }\n\n    return GameStatus.OnGoing;\n}\n\nexport function check(\n    bitmap: CellStatus[][],\n    row: number,\n    column: number,\n    winningCount: number,\n): GameStatus {\n    // add rows\n    const arrays: CellStatus[][] = [...bitmap];\n\n    // add columns\n    for (let i = 0; i < column; i ++) {\n        arrays.push(new Array(row)\n            .fill(0)\n            .map((_, j) => bitmap[j][i]));\n    }\n\n    for (let i = 0; i < column; i ++) {\n        let temp = [];\n        let x = 0, y = i;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = 0; y = i;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    for (let i = 0; i < row; i ++) {\n        let temp = [];\n        let x = i, y = 0;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = i; y = 0;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    const results = arrays\n        .map(arr => checkRow(arr, winningCount))\n        .filter(x => x !== GameStatus.OnGoing);\n    if (results.length) return results[0];\n\n    if (bitmap.some(row => row.some(c => c === CellStatus.Blank))) return GameStatus.OnGoing;\n    return GameStatus.Tie;\n}\n\n\nexport function useBoardGame(row: number, column: number, winningCount: number, firstHand: boolean) {\n    const [seq, setSeq] = useState<number>(0);\n    const [moves, setMoves] = useState<IMove[]>([]);\n    // true -> player 1 is going to place next chess; false -> player 2\n    const [player, setPlayer] = useState<boolean>(firstHand);\n\n    const placeChess = useCallback((x: number, y: number) => {\n        setMoves(pre => [...pre, {\n            x, y, seq,\n            status: player ? CellStatus.Player1 : CellStatus.Player2,\n        }]);\n        setSeq(pre => pre + 1);\n        setPlayer(pre => !pre);\n\n        return moves;\n    }, [seq, player]);\n\n    const bitmap = useMemo<CellStatus[][]>(() => {\n        const ret = new Array(row)\n            .fill(0)\n            .map(_ => new Array(column).fill(CellStatus.Blank));\n        moves.forEach(({ x, y, status }) => {\n            if (x < 0 || y < 0 || x >= row || y >= column) {\n                console.error(`Invalid move: (${x}, ${y})`);\n                console.log(\"current moves:\", moves);\n            }\n            ret[x][y] = status;\n        });\n        return ret;\n    }, [moves, column, row]);\n\n    const gameStatus = useMemo<GameStatus>(\n        () => check(bitmap, row, column, winningCount),\n        [bitmap, row, column, winningCount],\n    );\n\n    const restart = useCallback(() => {\n        setSeq(0);\n        setMoves([]);\n        setPlayer(firstHand);\n    }, [firstHand]);\n\n    return { bitmap, placeChess, gameStatus, player, restart, seq };\n}\n","import React from \"react\";\n\n\nconst HEIGHT = window.innerHeight;\nconst WIDTH = window.innerWidth;\nconst BASE = HEIGHT < WIDTH ? HEIGHT : WIDTH;\nconst BOARD_SIZE = BASE * 0.6;\n\nexport const RATE = Math.round(BOARD_SIZE / 15);\nconst OFFSET = Math.ceil((BOARD_SIZE - RATE * 14) * 0.5);\nconst RADIUS = RATE * 0.4;\n\n\nexport function init(canvas: HTMLCanvasElement | null) {\n    if (!canvas) {\n        console.error(\"Canvas is null\");\n        return;\n    }\n\n    canvas.width = BOARD_SIZE;\n    canvas.height = BOARD_SIZE;\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    for (let i = 0; i < 15; i++) {\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(OFFSET + i * RATE, OFFSET);\n        ctx.lineTo(OFFSET + i * RATE, BOARD_SIZE - OFFSET);\n        ctx.stroke();\n\n        ctx.moveTo(OFFSET, i * RATE + OFFSET);\n        ctx.lineTo(BOARD_SIZE - OFFSET, i * RATE + OFFSET);\n        ctx.stroke();\n    }\n}\n\nexport function draw(canvas: HTMLCanvasElement | null, x: number, y: number, turn: number) {\n    const ctx = canvas?.getContext('2d');\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    const x1 = x * RATE + OFFSET;\n    const y1 = y * RATE + OFFSET;\n\n    ctx.fillStyle = turn % 2 === 0 ? \"#000\" : \"#fff\";\n\n    ctx.beginPath();\n    ctx.arc(x1, y1, RADIUS, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = turn % 2 === 0 ? \" #fff\" : \" #000\";\n    ctx.font=\"20px sans-serif\";\n    const text = `${turn + 1}`;\n    const x2 = x1 - text.length * 10 + 8;\n    const y2 = y1 + 5;\n    ctx.fillText(text, x2, y2);\n};\n\n\nexport function client2Coordinate(e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n    const cx = e.clientX - OFFSET - (window.innerWidth- BOARD_SIZE) / 2;\n    const cy = e.clientY - OFFSET - (window.innerHeight- BOARD_SIZE) / 2;\n\n    const x = Math.round(cx / RATE), y = Math.round(cy / RATE);\n    return { x, y };\n}\n\nexport function coordinate2client(cx: number, cy: number) {\n    const x = cx * RATE + OFFSET + (window.innerWidth - BOARD_SIZE) / 2;\n    const y = cy * RATE + OFFSET + (window.innerHeight - BOARD_SIZE) / 2;\n\n    return { x, y };\n}","import React, {\n    forwardRef, useCallback, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef,\n    useState\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport { client2Coordinate, coordinate2client, draw, init, RATE } from \"./canvasUtils\";\nimport styled from \"styled-components\";\n\nconst ROW = 15;\nconst COL = 15;\nconst WINNING_COUNT = 5;\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n    setHighlighPos: (x: number, y: number) => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\nconst Preview = styled.span`\n    height: ${RATE - 1}px;\n    width: ${RATE - 1}px;\n    opacity: 0.2;\n    background-color: #fff;\n    border-radius: 50%;\n    display: inline-block;\n    position: fixed;\n    pointer-events: none;\n`;\n\nconst Highlight = styled.span`\n    height: ${RATE - 7}px;\n    width: ${RATE - 7}px;\n    border: 2px solid #dadada;\n    border-radius: 50%;\n    display: inline-block;\n    position: fixed;\n    pointer-events: none;\n    outline: none;\n    border-color: #9ecaed;\n    box-shadow: 0 0 10px #9ecaed;\n`;\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const {\n        bitmap, placeChess, gameStatus, player, restart, seq\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const [highlightPos, setHighlightPos] = useState<{ x: number; y: number; } | null>();\n\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        },\n        restart: () => {\n            restart();\n            init(canvasRef.current);\n            setPreviewPos(null);\n            setHighlightPos(null);\n        },\n        setHighlighPos: (x, y) => {\n            const { x: x1, y: y1 } = coordinate2client(x, y);\n            setHighlightPos({ x: x1 - RATE / 2 + 1.1, y: y1 - RATE / 2 });\n        },\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap]);\n\n    useEffect(() => {\n        init(canvasRef.current);\n    }, []);\n\n    const onClick = useCallback((e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n        if (!enable) return;\n\n        const { x, y } = client2Coordinate(e);\n\n        if (bitmap[x][y] === CellStatus.Blank) {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        }\n    }, [seq, bitmap]);\n\n    const [previewPos, setPreviewPos] = useState<{ x: number; y: number; } | null>();\n\n    const showPreview = useCallback((e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n        const { x: x1, y: y1 } = client2Coordinate(e);\n        const { x: x2, y: y2 } = coordinate2client(x1, y1);\n        setPreviewPos({ x: x2 - RATE / 2, y: y2 - RATE / 2 });\n    }, []);\n\n    return (\n        <div>\n            <canvas ref={canvasRef}\n                onClick={onClick}\n                onMouseMove={showPreview}\n            />\n            { previewPos && <Preview style={{ top: previewPos.y, left: previewPos.x }} /> }\n            { highlightPos && <Highlight style={{ top: highlightPos.y, left: highlightPos.x }} /> }\n        </div>\n    );\n});\n","import { Move } from \"../interfaces/game.interfaces\";\n\nexport function findBestMove(board: number[][]): Move {\n    return negamax(board, 2, -1, -Infinity, Infinity);\n}\n\n\nexport const negamax = (\n    board: number[][],\n    depth: number,\n    color: number,\n    alpha: number,\n    beta: number\n): Move => {\n    let bestMove: Move = { x: -1, y: -1, score: -Infinity };\n\n    if (depth === 0 || isGameOver(board)) {\n        return { x: -1, y: -1, score: color * evaluateBoard(board) };\n    }\n\n    let moves = generateMoves(board);\n\n    for (let move of moves) {\n        board[move.x][move.y] = color;\n\n        const nextMove = negamax(board, depth - 1, -color, -beta, -alpha);\n        nextMove.score = -nextMove.score;\n\n        board[move.x][move.y] = 0; // Undo the move\n\n        if (nextMove.score > bestMove.score) {\n            bestMove = { x: move.x, y: move.y, score: nextMove.score };\n        }\n\n        alpha = Math.max(alpha, nextMove.score);\n        if (alpha >= beta) {\n            break; // Beta cutoff\n        }\n    }\n\n    return bestMove;\n};\n\n\n// Generate possible moves, ordered by proximity to the last moves\nconst generateMoves = (board: number[][]): Move[] => {\n    let moves: Move[] = [];\n\n    for (let x = 0; x < board.length; x++) {\n        for (let y = 0; y < board[x].length; y++) {\n            if (board[x][y] === 0 && hasAdjacent(board, x, y)) {\n                moves.push({ x, y, score: 0 });\n            }\n        }\n    }\n\n    // Optionally, sort moves by heuristic score to improve pruning\n    moves.sort((a, b) => evaluateMove(board, b) - evaluateMove(board, a));\n\n    return moves;\n};\n\n// Check if a move is adjacent to any occupied cell\nconst hasAdjacent = (board: number[][], x: number, y: number): boolean => {\n    const directions = [\n        [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, -1], [1, -1], [-1, 1]\n    ];\n\n    for (let [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < board.length && ny >= 0 && ny < board.length && board[nx][ny] !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// Heuristically evaluate a move\nconst evaluateMove = (board: number[][], move: Move): number => {\n    board[move.x][move.y] = 1; // Assume the AI plays here\n    const score = evaluateBoard(board);\n    board[move.x][move.y] = 0; // Undo the move\n    return score;\n};\n\nconst evaluateBoard = (board: number[][]): number => {\n    let score = 0;\n\n    // Check rows, columns, and diagonals for potential scores\n    score += evaluateLines(board);\n    score += evaluateLines(transpose(board));\n    score += evaluateDiagonals(board);\n    score += evaluateDiagonals(transpose(board));\n\n    return score;\n};\n\n// Helper function to transpose the board (rows become columns)\nconst transpose = (board: number[][]): number[][] => {\n    return board[0].map((_, colIndex) => board.map(row => row[colIndex]));\n};\n\n// Evaluate rows and columns\nconst evaluateLines = (board: number[][]): number => {\n    let score = 0;\n\n    for (let row of board) {\n        score += evaluateLine(row);\n    }\n\n    return score;\n};\n\n// Evaluate diagonals (both major and minor)\nconst evaluateDiagonals = (board: number[][]): number => {\n    let score = 0;\n    const size = board.length;\n\n    // Major diagonals\n    for (let i = -size + 1; i < size; i++) {\n        let majorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = x + i;\n            if (y >= 0 && y < size) {\n                majorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(majorDiagonal);\n    }\n\n    // Minor diagonals\n    for (let i = 0; i < 2 * size - 1; i++) {\n        let minorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = i - x;\n            if (y >= 0 && y < size) {\n                minorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(minorDiagonal);\n    }\n\n    return score;\n};\n\n// Evaluate a single line (row, column, or diagonal)\nconst evaluateLine = (line: number[]): number => {\n    let score = 0;\n\n    for (let i = 0; i < line.length - 4; i++) {\n        const segment = line.slice(i, i + 5);\n        score += evaluateSegment(segment);\n    }\n\n    return score;\n};\n\n// Evaluate a segment of 5 cells\nconst evaluateSegment = (segment: number[]): number => {\n    const countX = segment.filter(cell => cell === 1).length;\n    const countO = segment.filter(cell => cell === -1).length;\n\n    if (countX === 5) return 100000; // Win for X\n    if (countO === 5) return -100000; // Win for O\n    if (countX > 0 && countO > 0) return 0; // Blocked line\n    if (countX === 4) return 1000;\n    if (countO === 4) return -1000;\n    if (countX === 3) return 100;\n    if (countO === 3) return -100;\n    if (countX === 2) return 10;\n    if (countO === 2) return -10;\n\n    return 0;\n};\n\nconst isGameOver = (board: number[][]): boolean => {\n    return checkWinningCondition(board, 1) || checkWinningCondition(board, -1);\n};\n\n// Check if a player has won\nconst checkWinningCondition = (board: number[][], player: number): boolean => {\n    const size = board.length;\n\n    // Check rows, columns, and diagonals\n    for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n            if (\n                checkDirection(board, x, y, player, 1, 0) || // Check row\n                checkDirection(board, x, y, player, 0, 1) || // Check column\n            checkDirection(board, x, y, player, 1, 1) || // Check major diagonal\n        checkDirection(board, x, y, player, 1, -1)   // Check minor diagonal\n            ) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// Check a direction (e.g., row, column, diagonal) for a win\nfunction checkDirection(\n    board: number[][],\n    startX: number,\n    startY: number,\n    player: number,\n    deltaX: number,\n    deltaY: number\n): boolean {\n    const size = board.length;\n    let count = 0;\n\n    for (let i = 0; i < 5; i++) {\n        const x = startX + i * deltaX;\n        const y = startY + i * deltaY;\n\n        if (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === player) {\n            count++;\n        } else {\n            break;\n        }\n\n        if (count === 5) {\n            return true;\n        }\n    }\n\n    return false;\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { Button } from \"../../components/button\";\nimport { IResultRef, Result } from \"../../components/result\";\nimport { Board, IBoardRef } from \"./board\";\nimport { findBestMove } from \"../../algorithms/negmax\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\n\nexport const GomokuPage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 200);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        resultRef.current?.show(\"loading\");\n\n        const res = findBestMove(board);\n        console.log(res);\n        setTimeout(() => {\n            boardRef.current?.placeChess(res.x, res.y);\n            boardRef.current?.setHighlighPos(res.x, res.y);\n            resultRef.current?.hide();\n        }, 500);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React, {\n    FunctionComponent, forwardRef, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef,\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport styled from \"styled-components\";\n\nconst ROW = 3;\nconst COL = 3;\nconst WINNING_COUNT = 3;\nconst SIZE = 20;\n\nconst EmptyCell = styled.td`\n    height: ${SIZE}vmin;\n    width: ${SIZE}vmin;\n    font-size: calc(${SIZE}vmin - 20px);\n    line-height: calc(${SIZE}vmin - 20px);\n    cursor: pointer;\n    text-align: center;\n`;\n\nconst Player1Cell = styled(EmptyCell)`\n    &:after {\n        content: \"⭕️\";\n    }\n`;\n\nconst Player2Cell = styled(EmptyCell)`\n    &:after {\n        content: \"❌\";\n    }\n`;\n\nconst Cell: FunctionComponent<{\n    status: CellStatus;\n    onClick: () => void;\n}> = ({ status, onClick }) => {\n    if (status === CellStatus.Blank) return <EmptyCell onClick={onClick} />\n\n    return status === CellStatus.Player1\n        ? <Player1Cell />\n        : <Player2Cell />;\n};\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\nconst Table = styled.table`\n    border-collapse: collapse;\n\n    td + td,\n    th + th { border-left: 2vmin solid #fff; }\n    tr + tr { border-top: 2vmin solid #fff; }\n`;\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const boardRef = useRef(null);\n    const {\n        bitmap, placeChess, gameStatus, player, restart,\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    const board = useMemo(() => bitmap.map((r, x) => (\n        <tr key={`row-${x}`}>\n            {\n                r.map((c, y) => (\n                    <Cell key={`cell-${x}-${y}`}\n                        status={c}\n                        onClick={() => enable && placeChess(x, y)}\n                    />\n                ))\n            }\n        </tr>\n    )), [bitmap, placeChess, enable]);\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => placeChess(x, y),\n        restart: () => restart(),\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap, gameStatus, onPlayerPlaced]);\n\n    return (\n        <Table ref={boardRef}>\n            <tbody>\n                {board}\n            </tbody>\n        </Table>\n    );\n});\n","// Define the board size\nconst SIZE = 3;\n\nexport function findBestMove(board: number[][]): { x: number, y: number, score: number } {\n    let bestScore = -Infinity;\n    let bestMove = { x: -1, y: -1, score: bestScore };\n\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) {\n                board[i][j] = -1; // AI makes a move\n                const score = minimax(board, 0, false);\n                board[i][j] = 0; // Undo the move\n\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestMove = { x: i, y: j, score: bestScore };\n                }\n            }\n        }\n    }\n\n    return bestMove;\n}\n\n// Minimax function to evaluate the board\nfunction minimax(board: number[][], depth: number, isMaximizing: boolean): number {\n    let score = evaluate(board);\n\n    if (score === 10) return score - depth;\n    if (score === -10) return score + depth;\n    if (isMovesLeft(board) === false) return 0;\n\n    if (isMaximizing) {\n        let bestScore = -Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = -1; // AI makes a move\n                    bestScore = Math.max(bestScore, minimax(board, depth + 1, false));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    } else {\n        let bestScore = Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = 1; // Player makes a move\n                    bestScore = Math.min(bestScore, minimax(board, depth + 1, true));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    }\n}\n\nfunction evaluate(board: number[][]): number {\n    for (let row = 0; row < SIZE; row++) {\n        if (board[row][0] === board[row][1] && board[row][1] === board[row][2]) {\n            if (board[row][0] === -1) return 10;\n            else if (board[row][0] === 1) return -10;\n        }\n    }\n\n    for (let col = 0; col < SIZE; col++) {\n        if (board[0][col] === board[1][col] && board[1][col] === board[2][col]) {\n            if (board[0][col] === -1) return 10;\n            else if (board[0][col] === 1) return -10;\n        }\n    }\n\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        if (board[0][0] === -1) return 10;\n        else if (board[0][0] === 1) return -10;\n    }\n\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        if (board[0][2] === -1) return 10;\n        else if (board[0][2] === 1) return -10;\n    }\n\n    return 0;\n}\n\n// Function to check if there are any moves left\nfunction isMovesLeft(board: number[][]): boolean {\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) return true;\n        }\n    }\n    return false;\n}\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { Board, IBoardRef } from \"./board\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { findBestMove } from \"../../algorithms/minmax\";\nimport { Button } from \"../../components/button\";\nimport styled from \"styled-components\";\nimport { IResultRef, Result } from \"../../components/result\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\nexport const TicTacToePage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 400);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        const res = findBestMove(board);\n\n        boardRef.current?.placeChess(res.x, res.y);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React from 'react';\nimport { createHashRouter, RouterProvider } from \"react-router-dom\";\nimport { HomePage, TicTacToePage, GomokuPage } from './pages';\nimport './App.css';\n\nconst router = createHashRouter([\n    {\n        path: \"/tic-tac-toe\",\n        element: <TicTacToePage />,\n    },\n    {\n        path: \"/gomoku\",\n        element: <GomokuPage />\n    },\n    {\n        path: \"/\",\n        element: <HomePage />\n    },\n]);\n\nexport const App = () => {\n    return (\n        <RouterProvider router={router} />\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport { App } from './App';\n\nconst root = ReactDOM.createRoot(\n    document.getElementById('root') as HTMLElement\n);\n\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n"],"sourceRoot":""}
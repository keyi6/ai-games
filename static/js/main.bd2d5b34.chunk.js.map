{"version":3,"sources":["components/button.tsx","components/page.tsx","pages/home/home.tsx","interfaces/game.interfaces.ts","components/result.tsx","hooks/useBoardGame.ts","pages/gomoku/canvasUtils.ts","pages/gomoku/board.tsx","algorithms/negmax.ts","pages/gomoku/gomoku.tsx","pages/tic-tac-toe/board.tsx","algorithms/minmax.ts","pages/tic-tac-toe/tic-tac-toe.tsx","App.tsx","index.tsx"],"names":["ButtonWrapper","styled","button","_templateObject","_taggedTemplateLiteral","Button","_ref","children","onClick","delay","active","setActive","useState","ref","useRef","onClickWithAnimation","useCallback","_ref$current","current","focus","setTimeout","_ref$current2","blur","React","createElement","Page","main","sample","Title","h1","About","div","_templateObject2","HomePage","navigate","useNavigate","style","gap","target","href","rel","CellStatus","GameStatus","ResultWrapper","Result","forwardRef","_","status","setStatus","OnGoing","text","useMemo","Player1Won","Player2Won","useImperativeHandle","show","hide","opacity","check","bitmap","row","column","winningCount","arrays","i","push","Array","fill","map","j","temp","x","y","results","arr","length","Blank","slice","every","console","debug","Player1","checkRow","filter","some","c","Tie","useBoardGame","firstHand","seq","setSeq","moves","setMoves","player","setPlayer","placeChess","pre","Player2","ret","forEach","gameStatus","restart","HEIGHT","window","innerHeight","WIDTH","innerWidth","BOARD_SIZE","MARGIN_U","toString","MARGIN_L","RATE","Math","round","OFFSET","ceil","RADIUS","init","canvas","error","width","height","ctx","getContext","strokeStyle","lineWidth","moveTo","lineTo","stroke","draw","turn","x1","y1","fillStyle","beginPath","arc","PI","closePath","font","concat","x2","y2","fillText","Board","onStatusChange","onPlayerPlaced","canvasRef","enable","useLayoutEffect","useEffect","e","cx","clientX","cy","clientY","click2Coordinates","position","top","left","negamax","board","depth","color","alpha","beta","bestMove","score","Infinity","isGameOver","evaluateBoard","generateMoves","move","nextMove","max","hasAdjacent","sort","a","b","evaluateMove","directions","dx","dy","nx","ny","evaluateLines","transpose","evaluateDiagonals","colIndex","evaluateLine","size","majorDiagonal","minorDiagonal","line","segment","evaluateSegment","countX","cell","countO","checkWinningCondition","checkDirection","startX","startY","deltaX","deltaY","count","ActionBar","section","GomokuPage","boardRef","resultRef","_resultRef$current","log","_resultRef$current2","_resultRef$current3","res","findBestMove","_boardRef$current","_resultRef$current4","onClickRestart","_boardRef$current2","_resultRef$current5","EmptyCell","td","Player1Cell","Player2Cell","_templateObject3","Cell","Table","table","_templateObject4","_ref2","r","key","SIZE","minimax","isMaximizing","col","evaluate","isMovesLeft","bestScore","min","TicTacToePage","router","createBrowserRouter","path","element","App","RouterProvider","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.bd2d5b34.chunk.js","sourcesContent":["import React, { PropsWithChildren, useCallback, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nconst ButtonWrapper = styled.button`\n    all:  unset;\n    min-width: 140px;\n    text-align: center;\n    color: #333;\n    text-decoration: none;\n    text-transform: uppercase;\n    letter-spacing: 2.8px;\n    background-color:  #fff;\n    padding: 15px 50px;\n    border-radius: 5rem;\n    box-shadow:  1px 2.9px 16px #aaa;\n    transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n    cursor: pointer;\n\n    &:hover {\n        box-shadow: 3px 4.9px 16px #aaa;\n        letter-spacing:  5px\n    }\n\n    &:focus {\n        transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n        padding: 15px 2px;\n        width: 100vw;\n        height: 100vh;\n        position: fixed;\n        top: 0;\n        left: 0;\n        text-align: center;\n        font-size: 5rem;\n        border-radius: 0%;\n    }\n`;\n\nexport interface IButtonProps {\n    onClick?: () => void;\n    /**\n     * If set true, the `onClick` will be trigger after animation\n     */\n    delay?: boolean;\n}\n\nexport const Button = ({\n    children,\n    onClick = () => {},\n    delay = false,\n}: PropsWithChildren<IButtonProps>) => {\n    const [active, setActive] = useState<boolean>(false);\n    const ref = useRef<HTMLButtonElement>(null);\n\n    const onClickWithAnimation = useCallback(() => {\n        if (active) return;\n\n        if (!delay) onClick();\n\n        setActive(true);\n        ref.current?.focus();\n        setTimeout(() => {\n            setActive(false);\n            ref.current?.blur();\n            if (delay) onClick();\n        }, 700);\n    }, [onClick, delay, active]);\n\n    return (\n        <ButtonWrapper ref={ref} onClick={onClickWithAnimation}>\n            {children}\n        </ButtonWrapper>\n    );\n};","import React from \"react\";\nimport sample from \"lodash/sample\";\nimport styled from \"styled-components\";\n\nconst COLOR_LIST = ['#606470', '#3c79ce', '#F9CE00', '#4CAF50', '#FF9800'];\n\nexport const Page = styled.main`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: ${sample(COLOR_LIST)};\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n","import React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Button } from \"../../components/button\";\nimport { Page } from \"../../components/page\";\nimport styled from \"styled-components\";\n\nconst Title = styled.h1`\n    color: #fff;\n    font-size: 6em;\n`;\n\nconst About = styled.div`\n    position: absolute;\n    bottom: 40px;\n    & a {\n        all: unset;\n        cursor: pointer;\n        text-decoration: underline;\n        color: #fff;\n    }\n`;\n\nexport const HomePage = () => {\n    const navigate = useNavigate();\n\n    return (\n        <Page style={{ gap: 20 }}>\n            <Title>Games</Title>\n            <Button onClick={() => navigate(\"/tic-tac-toe\")} delay={true}>Tic Tac Toe</Button>\n            <Button onClick={() => navigate(\"/gomoku\")} delay={true}>Gomoku</Button>\n            <About>\n                <a target=\"_blank\" href=\"https://github.com/keyi6/ai-games/\" rel=\"noopener noreferrer\">https://github.com/keyi6/ai-games/</a>\n            </About>\n        </Page>\n    );\n};\n","export enum CellStatus {\n    Blank = 0,\n    Player1 = 1,\n    Player2 = -1,\n}\n\nexport enum GameStatus {\n    OnGoing,\n    Tie = \"tie\",\n    Player1Won = \"player 1\",\n    Player2Won = \"player 2\",\n}\n\nexport interface IMove {\n    x: number;\n    y: number;\n    status: CellStatus;\n    seq: number;\n}\n\nexport interface Move {\n    x: number;\n    y: number;\n    score: number;\n};","import React, { forwardRef, useImperativeHandle, useMemo, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { GameStatus } from \"../interfaces/game.interfaces\";\n\nexport const ResultWrapper = styled.div`\n    position: absolute;\n    text-decoration: none;\n    text-transform: uppercase;\n    top: 0;\n    left: 0;\n    color: #333;\n    background-color: #fff;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    font-size: 6rem;\n    height: 100vh;\n    width: 100vw;\n    z-index: 999;\n    text-align: center;\n`;\n\nexport interface IResultRef {\n    show: (status: GameStatus | \"loading\") => void;\n    hide: () => void;\n}\n\nexport const Result = forwardRef<IResultRef>((_, ref) => {\n    const [active, setActive] = useState<boolean>(false);\n    const [status, setStatus] = useState<GameStatus | \"loading\">(GameStatus.OnGoing);\n    const text = useMemo(() => {\n        if (status === \"loading\") return \"Calculating...\";\n        if (status === GameStatus.Player1Won) return \"You won\";\n        if (status === GameStatus.Player2Won) return \"You lost\";\n        return \"Tie\";\n    }, [status]);\n\n    useImperativeHandle(ref, (): IResultRef => ({\n        show: (status) => {\n            setStatus(status);\n            setActive(true);\n        },\n\n        hide: () => {\n            setActive(false);\n        },\n    }));\n    \n    if (!active) return null;\n    return (\n        <ResultWrapper style={{ opacity: status === \"loading\" ? 0.1 : 0.8 }}>\n            {text}\n        </ResultWrapper>\n    );\n});\n","import { useState, useCallback, useMemo } from \"react\";\nimport { GameStatus, IMove, CellStatus } from \"../interfaces/game.interfaces\";\n\nfunction checkRow(arr: CellStatus[], winningCount: number): GameStatus {\n    if (arr.length < winningCount) return GameStatus.OnGoing;\n    for (let i = 0; i + winningCount <= arr.length; i ++) {\n        if (arr[i] === CellStatus.Blank) continue;\n\n        if (arr.slice(i + 1, i + winningCount).every(x => x === arr[i])) {\n            console.debug(\"Matched\", arr);\n            return arr[i] === CellStatus.Player1\n                ? GameStatus.Player1Won\n                : GameStatus.Player2Won;\n        }\n    }\n\n    return GameStatus.OnGoing;\n}\n\nexport function check(\n    bitmap: CellStatus[][],\n    row: number,\n    column: number,\n    winningCount: number,\n): GameStatus {\n    // add rows\n    const arrays: CellStatus[][] = [...bitmap];\n\n    // add columns\n    for (let i = 0; i < column; i ++) {\n        arrays.push(new Array(row)\n            .fill(0)\n            .map((_, j) => bitmap[j][i]));\n    }\n\n    for (let i = 0; i < column; i ++) {\n        let temp = [];\n        let x = 0, y = i;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = 0; y = i;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    for (let i = 0; i < row; i ++) {\n        let temp = [];\n        let x = i, y = 0;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = i; y = 0;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    const results = arrays\n        .map(arr => checkRow(arr, winningCount))\n        .filter(x => x !== GameStatus.OnGoing);\n    if (results.length) return results[0];\n\n    if (bitmap.some(row => row.some(c => c === CellStatus.Blank))) return GameStatus.OnGoing;\n    return GameStatus.Tie;\n}\n\n\nexport function useBoardGame(row: number, column: number, winningCount: number, firstHand: boolean) {\n    const [seq, setSeq] = useState<number>(0);\n    const [moves, setMoves] = useState<IMove[]>([]);\n    // true -> player 1 is going to place next chess; false -> player 2\n    const [player, setPlayer] = useState<boolean>(firstHand);\n\n    const placeChess = useCallback((x: number, y: number) => {\n        setMoves(pre => [...pre, {\n            x, y, seq,\n            status: player ? CellStatus.Player1 : CellStatus.Player2,\n        }]);\n        setSeq(pre => pre + 1);\n        setPlayer(pre => !pre);\n\n        return moves;\n    }, [seq, player]);\n\n    const bitmap = useMemo<CellStatus[][]>(() => {\n        const ret = new Array(row)\n            .fill(0)\n            .map(_ => new Array(column).fill(CellStatus.Blank));\n        moves.forEach(({ x, y, status }) => ret[x][y] = status);\n        return ret;\n    }, [moves, column, row]);\n\n    const gameStatus = useMemo<GameStatus>(\n        () => check(bitmap, row, column, winningCount),\n        [bitmap, row, column, winningCount],\n    );\n\n    const restart = useCallback(() => {\n        setSeq(0);\n        setMoves([]);\n        setPlayer(firstHand);\n    }, [firstHand]);\n\n    return { bitmap, placeChess, gameStatus, player, restart, seq };\n}\n","import React from \"react\";\n\n\nconst HEIGHT = window.innerHeight;\nconst WIDTH = window.innerWidth;\nconst BASE = HEIGHT < WIDTH ? HEIGHT : WIDTH;\nconst BOARD_SIZE = BASE * 0.6;\n\nexport const MARGIN_U = ((HEIGHT - BOARD_SIZE) / 2).toString() + 'px';\nexport const MARGIN_L = ((WIDTH - BOARD_SIZE) / 2).toString() + 'px';\n\nconst RATE = Math.round(BOARD_SIZE / 15);\nconst OFFSET = Math.ceil((BOARD_SIZE - RATE * 14) * 0.5);\nconst RADIUS = RATE * 0.4;\n\n\nexport function init(canvas: HTMLCanvasElement | null) {\n    if (!canvas) {\n        console.error(\"Canvas is null\");\n        return;\n    }\n\n    canvas.width = BOARD_SIZE;\n    canvas.height = BOARD_SIZE;\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    for (let i = 0; i < 15; i++) {\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(OFFSET + i * RATE, OFFSET);\n        ctx.lineTo(OFFSET + i * RATE, BOARD_SIZE - OFFSET);\n        ctx.stroke();\n\n        ctx.moveTo(OFFSET, i * RATE + OFFSET);\n        ctx.lineTo(BOARD_SIZE - OFFSET, i * RATE + OFFSET);\n        ctx.stroke();\n    }\n}\n\nexport function draw(canvas: HTMLCanvasElement | null, x: number, y: number, turn: number) {\n    const ctx = canvas?.getContext('2d');\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    const x1 = x * RATE + OFFSET;\n    const y1 = y * RATE + OFFSET;\n\n    ctx.fillStyle = turn % 2 === 0 ? \"#000\" : \"#fff\";\n\n    ctx.beginPath();\n    ctx.arc(x1, y1, RADIUS, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = turn % 2 === 0 ? \" #fff\" : \" #000\";\n    ctx.font=\"20px sans-serif\";\n    const text = `${turn + 1}`;\n    const x2 = x1 - RADIUS - text.length * 10 + 23;\n    const y2 = y1 + RADIUS - 10;\n    ctx.fillText(text, x2, y2);\n};\n\n\nexport function click2Coordinates(e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n    const cx = e.clientX - OFFSET - (WIDTH - BOARD_SIZE) / 2;\n    const cy = e.clientY - OFFSET - (HEIGHT - BOARD_SIZE) / 2;\n\n    const x = Math.round(cx / RATE), y = Math.round(cy / RATE);\n    return { x, y };\n}","import React, {\n    forwardRef, useCallback, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport { MARGIN_L, MARGIN_U, click2Coordinates, draw, init } from \"./canvasUtils\";\n\nconst ROW = 15;\nconst COL = 15;\nconst WINNING_COUNT = 5;\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const {\n        bitmap, placeChess, gameStatus, player, restart, seq\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        },\n        restart: () => {\n            restart();\n            init(canvasRef.current);\n        }\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap]);\n\n    useEffect(() => {\n        init(canvasRef.current);\n    }, []);\n\n    const onClick = useCallback((e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n        if (!enable) return;\n\n        const { x, y } = click2Coordinates(e);\n\n        if (bitmap[x][y] === CellStatus.Blank) {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        }\n    }, [seq, bitmap]);\n\n    return (\n        <div>\n            <canvas ref={canvasRef}\n                onClick={onClick}\n                style={{\n                    position: 'absolute',\n                    top: MARGIN_U,\n                    left: MARGIN_L\n                }}\n            />\n\n        </div>\n    );\n});\n","import { Move } from \"../interfaces/game.interfaces\";\n\nexport function findBestMove(board: number[][]): Move {\n    return negamax(board, 2, -1, -Infinity, Infinity);\n}\n\n\nexport const negamax = (\n    board: number[][],\n    depth: number,\n    color: number,\n    alpha: number,\n    beta: number\n): Move => {\n    let bestMove: Move = { x: -1, y: -1, score: -Infinity };\n\n    if (depth === 0 || isGameOver(board)) {\n        return { x: -1, y: -1, score: color * evaluateBoard(board) };\n    }\n\n    let moves = generateMoves(board);\n\n    for (let move of moves) {\n        board[move.x][move.y] = color;\n\n        const nextMove = negamax(board, depth - 1, -color, -beta, -alpha);\n        nextMove.score = -nextMove.score;\n\n        board[move.x][move.y] = 0; // Undo the move\n\n        if (nextMove.score > bestMove.score) {\n            bestMove = { x: move.x, y: move.y, score: nextMove.score };\n        }\n\n        alpha = Math.max(alpha, nextMove.score);\n        if (alpha >= beta) {\n            break; // Beta cutoff\n        }\n    }\n\n    return bestMove;\n};\n\n\n// Generate possible moves, ordered by proximity to the last moves\nconst generateMoves = (board: number[][]): Move[] => {\n    let moves: Move[] = [];\n\n    for (let x = 0; x < board.length; x++) {\n        for (let y = 0; y < board[x].length; y++) {\n            if (board[x][y] === 0 && hasAdjacent(board, x, y)) {\n                moves.push({ x, y, score: 0 });\n            }\n        }\n    }\n\n    // Optionally, sort moves by heuristic score to improve pruning\n    moves.sort((a, b) => evaluateMove(board, b) - evaluateMove(board, a));\n\n    return moves;\n};\n\n// Check if a move is adjacent to any occupied cell\nconst hasAdjacent = (board: number[][], x: number, y: number): boolean => {\n    const directions = [\n        [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, -1], [1, -1], [-1, 1]\n    ];\n\n    for (let [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < board.length && ny >= 0 && ny < board.length && board[nx][ny] !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// Heuristically evaluate a move\nconst evaluateMove = (board: number[][], move: Move): number => {\n    board[move.x][move.y] = 1; // Assume the AI plays here\n    const score = evaluateBoard(board);\n    board[move.x][move.y] = 0; // Undo the move\n    return score;\n};\n\nconst evaluateBoard = (board: number[][]): number => {\n    let score = 0;\n\n    // Check rows, columns, and diagonals for potential scores\n    score += evaluateLines(board);\n    score += evaluateLines(transpose(board));\n    score += evaluateDiagonals(board);\n    score += evaluateDiagonals(transpose(board));\n\n    return score;\n};\n\n// Helper function to transpose the board (rows become columns)\nconst transpose = (board: number[][]): number[][] => {\n    return board[0].map((_, colIndex) => board.map(row => row[colIndex]));\n};\n\n// Evaluate rows and columns\nconst evaluateLines = (board: number[][]): number => {\n    let score = 0;\n\n    for (let row of board) {\n        score += evaluateLine(row);\n    }\n\n    return score;\n};\n\n// Evaluate diagonals (both major and minor)\nconst evaluateDiagonals = (board: number[][]): number => {\n    let score = 0;\n    const size = board.length;\n\n    // Major diagonals\n    for (let i = -size + 1; i < size; i++) {\n        let majorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = x + i;\n            if (y >= 0 && y < size) {\n                majorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(majorDiagonal);\n    }\n\n    // Minor diagonals\n    for (let i = 0; i < 2 * size - 1; i++) {\n        let minorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = i - x;\n            if (y >= 0 && y < size) {\n                minorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(minorDiagonal);\n    }\n\n    return score;\n};\n\n// Evaluate a single line (row, column, or diagonal)\nconst evaluateLine = (line: number[]): number => {\n    let score = 0;\n\n    for (let i = 0; i < line.length - 4; i++) {\n        const segment = line.slice(i, i + 5);\n        score += evaluateSegment(segment);\n    }\n\n    return score;\n};\n\n// Evaluate a segment of 5 cells\nconst evaluateSegment = (segment: number[]): number => {\n    const countX = segment.filter(cell => cell === 1).length;\n    const countO = segment.filter(cell => cell === -1).length;\n\n    if (countX === 5) return 100000; // Win for X\n    if (countO === 5) return -100000; // Win for O\n    if (countX > 0 && countO > 0) return 0; // Blocked line\n    if (countX === 4) return 1000;\n    if (countO === 4) return -1000;\n    if (countX === 3) return 100;\n    if (countO === 3) return -100;\n    if (countX === 2) return 10;\n    if (countO === 2) return -10;\n\n    return 0;\n};\n\nconst isGameOver = (board: number[][]): boolean => {\n    return checkWinningCondition(board, 1) || checkWinningCondition(board, -1);\n};\n\n// Check if a player has won\nconst checkWinningCondition = (board: number[][], player: number): boolean => {\n    const size = board.length;\n\n    // Check rows, columns, and diagonals\n    for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n            if (\n                checkDirection(board, x, y, player, 1, 0) || // Check row\n                checkDirection(board, x, y, player, 0, 1) || // Check column\n            checkDirection(board, x, y, player, 1, 1) || // Check major diagonal\n        checkDirection(board, x, y, player, 1, -1)   // Check minor diagonal\n            ) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// Check a direction (e.g., row, column, diagonal) for a win\nfunction checkDirection(\n    board: number[][],\n    startX: number,\n    startY: number,\n    player: number,\n    deltaX: number,\n    deltaY: number\n): boolean {\n    const size = board.length;\n    let count = 0;\n\n    for (let i = 0; i < 5; i++) {\n        const x = startX + i * deltaX;\n        const y = startY + i * deltaY;\n\n        if (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === player) {\n            count++;\n        } else {\n            break;\n        }\n\n        if (count === 5) {\n            return true;\n        }\n    }\n\n    return false;\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { Button } from \"../../components/button\";\nimport { IResultRef, Result } from \"../../components/result\";\nimport { Board, IBoardRef } from \"./board\";\nimport { findBestMove } from \"../../algorithms/negmax\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\n\nexport const GomokuPage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 200);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        resultRef.current?.show(\"loading\");\n\n        const res = findBestMove(board);\n        console.log(res);\n        setTimeout(() => {\n            boardRef.current?.placeChess(res.x, res.y);\n            resultRef.current?.hide();\n        }, 500);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React, {\n    FunctionComponent, forwardRef, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef,\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport styled from \"styled-components\";\n\nconst ROW = 3;\nconst COL = 3;\nconst WINNING_COUNT = 3;\nconst SIZE = 20;\n\nconst EmptyCell = styled.td`\n    height: ${SIZE}vmin;\n    width: ${SIZE}vmin;\n    font-size: calc(${SIZE}vmin - 20px);\n    line-height: calc(${SIZE}vmin - 20px);\n    cursor: pointer;\n    text-align: center;\n`;\n\nconst Player1Cell = styled(EmptyCell)`\n    &:after {\n        content: \"⭕️\";\n    }\n`;\n\nconst Player2Cell = styled(EmptyCell)`\n    &:after {\n        content: \"❌\";\n    }\n`;\n\nconst Cell: FunctionComponent<{\n    status: CellStatus;\n    onClick: () => void;\n}> = ({ status, onClick }) => {\n    if (status === CellStatus.Blank) return <EmptyCell onClick={onClick} />\n\n    return status === CellStatus.Player1\n        ? <Player1Cell />\n        : <Player2Cell />;\n};\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\nconst Table = styled.table`\n    border-collapse: collapse;\n\n    td + td,\n    th + th { border-left: 2vmin solid #fff; }\n    tr + tr { border-top: 2vmin solid #fff; }\n`;\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const boardRef = useRef(null);\n    const {\n        bitmap, placeChess, gameStatus, player, restart,\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    const board = useMemo(() => bitmap.map((r, x) => (\n        <tr key={`row-${x}`}>\n            {\n                r.map((c, y) => (\n                    <Cell key={`cell-${x}-${y}`}\n                        status={c}\n                        onClick={() => enable && placeChess(x, y)}\n                    />\n                ))\n            }\n        </tr>\n    )), [bitmap, placeChess, enable]);\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => placeChess(x, y),\n        restart: () => restart(),\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap, gameStatus, onPlayerPlaced]);\n\n    return (\n        <Table ref={boardRef}>\n            <tbody>\n                {board}\n            </tbody>\n        </Table>\n    );\n});\n","// Define the board size\nconst SIZE = 3;\n\nexport function findBestMove(board: number[][]): { x: number, y: number, score: number } {\n    let bestScore = -Infinity;\n    let bestMove = { x: -1, y: -1, score: bestScore };\n\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) {\n                board[i][j] = -1; // AI makes a move\n                const score = minimax(board, 0, false);\n                board[i][j] = 0; // Undo the move\n\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestMove = { x: i, y: j, score: bestScore };\n                }\n            }\n        }\n    }\n\n    return bestMove;\n}\n\n// Minimax function to evaluate the board\nfunction minimax(board: number[][], depth: number, isMaximizing: boolean): number {\n    let score = evaluate(board);\n\n    if (score === 10) return score - depth;\n    if (score === -10) return score + depth;\n    if (isMovesLeft(board) === false) return 0;\n\n    if (isMaximizing) {\n        let bestScore = -Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = -1; // AI makes a move\n                    bestScore = Math.max(bestScore, minimax(board, depth + 1, false));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    } else {\n        let bestScore = Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = 1; // Player makes a move\n                    bestScore = Math.min(bestScore, minimax(board, depth + 1, true));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    }\n}\n\nfunction evaluate(board: number[][]): number {\n    for (let row = 0; row < SIZE; row++) {\n        if (board[row][0] === board[row][1] && board[row][1] === board[row][2]) {\n            if (board[row][0] === -1) return 10;\n            else if (board[row][0] === 1) return -10;\n        }\n    }\n\n    for (let col = 0; col < SIZE; col++) {\n        if (board[0][col] === board[1][col] && board[1][col] === board[2][col]) {\n            if (board[0][col] === -1) return 10;\n            else if (board[0][col] === 1) return -10;\n        }\n    }\n\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        if (board[0][0] === -1) return 10;\n        else if (board[0][0] === 1) return -10;\n    }\n\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        if (board[0][2] === -1) return 10;\n        else if (board[0][2] === 1) return -10;\n    }\n\n    return 0;\n}\n\n// Function to check if there are any moves left\nfunction isMovesLeft(board: number[][]): boolean {\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) return true;\n        }\n    }\n    return false;\n}\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { Board, IBoardRef } from \"./board\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { findBestMove } from \"../../algorithms/minmax\";\nimport { Button } from \"../../components/button\";\nimport styled from \"styled-components\";\nimport { IResultRef, Result } from \"../../components/result\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\nexport const TicTacToePage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 400);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        const res = findBestMove(board);\n\n        boardRef.current?.placeChess(res.x, res.y);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React from 'react';\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport { HomePage, TicTacToePage, GomokuPage } from './pages';\nimport './App.css';\n\nconst router = createBrowserRouter([\n    {\n        path: \"/tic-tac-toe\",\n        element: <TicTacToePage />,\n    },\n    {\n        path: \"/gomoku\",\n        element: <GomokuPage />\n    },\n    {\n        path: \"/\",\n        element: <HomePage />\n    },\n]);\n\nexport const App = () => {\n    return (\n        <RouterProvider router={router} />\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport { App } from './App';\n\nconst root = ReactDOM.createRoot(\n    document.getElementById('root') as HTMLElement\n);\n\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n"],"sourceRoot":""}
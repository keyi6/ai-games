{"version":3,"sources":["components/button.tsx","components/page.tsx","pages/home/home.tsx","interfaces/game.interfaces.ts","components/result.tsx","hooks/useBoardGame.ts","pages/gomoku/canvasUtils.ts","pages/gomoku/board.tsx","algorithms/negmax.ts","pages/gomoku/gomoku.tsx","pages/tic-tac-toe/board.tsx","algorithms/minmax.ts","pages/tic-tac-toe/tic-tac-toe.tsx","App.tsx","index.tsx"],"names":["ButtonWrapper","styled","button","_templateObject","_taggedTemplateLiteral","Button","_ref","children","onClick","delay","active","setActive","useState","ref","useRef","onClickWithAnimation","useCallback","_ref$current","current","focus","setTimeout","_ref$current2","blur","React","createElement","Page","main","sample","Title","h1","About","div","_templateObject2","HomePage","navigate","useNavigate","style","gap","target","href","rel","CellStatus","GameStatus","ResultWrapper","Result","forwardRef","_","status","setStatus","OnGoing","text","useMemo","Player1Won","Player2Won","useImperativeHandle","show","hide","opacity","check","bitmap","row","column","winningCount","arrays","i","push","Array","fill","map","j","temp","x","y","results","arr","length","Blank","slice","every","console","debug","Player1","checkRow","filter","some","c","Tie","useBoardGame","firstHand","seq","setSeq","moves","setMoves","player","setPlayer","placeChess","pre","Player2","ret","forEach","error","concat","log","gameStatus","restart","HEIGHT","window","innerHeight","WIDTH","innerWidth","BOARD_SIZE","RATE","Math","round","OFFSET","ceil","RADIUS","init","canvas","width","height","ctx","getContext","strokeStyle","lineWidth","moveTo","lineTo","stroke","draw","turn","x1","y1","fillStyle","beginPath","arc","PI","closePath","font","x2","y2","fillText","Board","onStatusChange","onPlayerPlaced","canvasRef","enable","useLayoutEffect","useEffect","e","cx","clientX","cy","clientY","click2Coordinates","negamax","board","depth","color","alpha","beta","bestMove","score","Infinity","isGameOver","evaluateBoard","generateMoves","move","nextMove","max","hasAdjacent","sort","a","b","evaluateMove","directions","dx","dy","nx","ny","evaluateLines","transpose","evaluateDiagonals","colIndex","evaluateLine","size","majorDiagonal","minorDiagonal","line","segment","evaluateSegment","countX","cell","countO","checkWinningCondition","checkDirection","startX","startY","deltaX","deltaY","count","ActionBar","section","GomokuPage","boardRef","resultRef","_resultRef$current","_resultRef$current2","_resultRef$current3","res","findBestMove","_boardRef$current","_resultRef$current4","onClickRestart","_boardRef$current2","_resultRef$current5","EmptyCell","td","Player1Cell","Player2Cell","_templateObject3","Cell","Table","table","_templateObject4","_ref2","r","key","SIZE","minimax","isMaximizing","col","evaluate","isMovesLeft","bestScore","min","TicTacToePage","router","createHashRouter","path","element","App","RouterProvider","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.fc063f4c.chunk.js","sourcesContent":["import React, { PropsWithChildren, useCallback, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nconst ButtonWrapper = styled.button`\n    all:  unset;\n    min-width: 140px;\n    text-align: center;\n    color: #333;\n    text-decoration: none;\n    text-transform: uppercase;\n    letter-spacing: 2.8px;\n    background-color:  #fff;\n    padding: 15px 50px;\n    border-radius: 5rem;\n    box-shadow:  1px 2.9px 16px #aaa;\n    transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n    cursor: pointer;\n\n    &:hover {\n        box-shadow: 3px 4.9px 16px #aaa;\n        letter-spacing:  5px\n    }\n\n    &:focus {\n        transition: 0.6s cubic-bezier(0.01, 1.69, 0.99, 0.94); \n        padding: 15px 2px;\n        width: 100vw;\n        height: 100vh;\n        position: fixed;\n        top: 0;\n        left: 0;\n        text-align: center;\n        font-size: 5rem;\n        border-radius: 0%;\n    }\n`;\n\nexport interface IButtonProps {\n    onClick?: () => void;\n    /**\n     * If set true, the `onClick` will be trigger after animation\n     */\n    delay?: boolean;\n}\n\nexport const Button = ({\n    children,\n    onClick = () => {},\n    delay = false,\n}: PropsWithChildren<IButtonProps>) => {\n    const [active, setActive] = useState<boolean>(false);\n    const ref = useRef<HTMLButtonElement>(null);\n\n    const onClickWithAnimation = useCallback(() => {\n        if (active) return;\n\n        if (!delay) onClick();\n\n        setActive(true);\n        ref.current?.focus();\n        setTimeout(() => {\n            setActive(false);\n            ref.current?.blur();\n            if (delay) onClick();\n        }, 700);\n    }, [onClick, delay, active]);\n\n    return (\n        <ButtonWrapper ref={ref} onClick={onClickWithAnimation}>\n            {children}\n        </ButtonWrapper>\n    );\n};","import React from \"react\";\nimport sample from \"lodash/sample\";\nimport styled from \"styled-components\";\n\nconst COLOR_LIST = ['#606470', '#3c79ce', '#F9CE00', '#4CAF50', '#FF9800'];\n\nexport const Page = styled.main`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: ${sample(COLOR_LIST)};\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n","import React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Button } from \"../../components/button\";\nimport { Page } from \"../../components/page\";\nimport styled from \"styled-components\";\n\nconst Title = styled.h1`\n    color: #fff;\n    font-size: 6em;\n`;\n\nconst About = styled.div`\n    position: absolute;\n    bottom: 40px;\n    & a {\n        all: unset;\n        cursor: pointer;\n        text-decoration: underline;\n        color: #fff;\n    }\n`;\n\nexport const HomePage = () => {\n    const navigate = useNavigate();\n\n    return (\n        <Page style={{ gap: 20 }}>\n            <Title>Games</Title>\n            <Button onClick={() => navigate(\"/tic-tac-toe\")} delay={true}>Tic Tac Toe</Button>\n            <Button onClick={() => navigate(\"/gomoku\")} delay={true}>Gomoku</Button>\n            <About>\n                <a target=\"_blank\" href=\"https://github.com/keyi6/ai-games/\" rel=\"noopener noreferrer\">https://github.com/keyi6/ai-games/</a>\n            </About>\n        </Page>\n    );\n};\n","export enum CellStatus {\n    Blank = 0,\n    Player1 = 1,\n    Player2 = -1,\n}\n\nexport enum GameStatus {\n    OnGoing,\n    Tie = \"tie\",\n    Player1Won = \"player 1\",\n    Player2Won = \"player 2\",\n}\n\nexport interface IMove {\n    x: number;\n    y: number;\n    status: CellStatus;\n    seq: number;\n}\n\nexport interface Move {\n    x: number;\n    y: number;\n    score: number;\n};","import React, { forwardRef, useImperativeHandle, useMemo, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { GameStatus } from \"../interfaces/game.interfaces\";\n\nexport const ResultWrapper = styled.div`\n    position: absolute;\n    text-decoration: none;\n    text-transform: uppercase;\n    top: 0;\n    left: 0;\n    color: #333;\n    background-color: #fff;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    font-size: 6rem;\n    height: 100vh;\n    width: 100vw;\n    z-index: 999;\n    text-align: center;\n`;\n\nexport interface IResultRef {\n    show: (status: GameStatus | \"loading\") => void;\n    hide: () => void;\n}\n\nexport const Result = forwardRef<IResultRef>((_, ref) => {\n    const [active, setActive] = useState<boolean>(false);\n    const [status, setStatus] = useState<GameStatus | \"loading\">(GameStatus.OnGoing);\n    const text = useMemo(() => {\n        if (status === \"loading\") return \"Calculating...\";\n        if (status === GameStatus.Player1Won) return \"You won\";\n        if (status === GameStatus.Player2Won) return \"You lost\";\n        return \"Tie\";\n    }, [status]);\n\n    useImperativeHandle(ref, (): IResultRef => ({\n        show: (status) => {\n            setStatus(status);\n            setActive(true);\n        },\n\n        hide: () => {\n            setActive(false);\n        },\n    }));\n    \n    if (!active) return null;\n    return (\n        <ResultWrapper style={{ opacity: status === \"loading\" ? 0.1 : 0.8 }}>\n            {text}\n        </ResultWrapper>\n    );\n});\n","import { useState, useCallback, useMemo } from \"react\";\nimport { GameStatus, IMove, CellStatus } from \"../interfaces/game.interfaces\";\n\nfunction checkRow(arr: CellStatus[], winningCount: number): GameStatus {\n    if (arr.length < winningCount) return GameStatus.OnGoing;\n    for (let i = 0; i + winningCount <= arr.length; i ++) {\n        if (arr[i] === CellStatus.Blank) continue;\n\n        if (arr.slice(i + 1, i + winningCount).every(x => x === arr[i])) {\n            console.debug(\"Matched\", arr);\n            return arr[i] === CellStatus.Player1\n                ? GameStatus.Player1Won\n                : GameStatus.Player2Won;\n        }\n    }\n\n    return GameStatus.OnGoing;\n}\n\nexport function check(\n    bitmap: CellStatus[][],\n    row: number,\n    column: number,\n    winningCount: number,\n): GameStatus {\n    // add rows\n    const arrays: CellStatus[][] = [...bitmap];\n\n    // add columns\n    for (let i = 0; i < column; i ++) {\n        arrays.push(new Array(row)\n            .fill(0)\n            .map((_, j) => bitmap[j][i]));\n    }\n\n    for (let i = 0; i < column; i ++) {\n        let temp = [];\n        let x = 0, y = i;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = 0; y = i;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    for (let i = 0; i < row; i ++) {\n        let temp = [];\n        let x = i, y = 0;\n        while (x < row && y < column) {\n            temp.push(bitmap[x][y]);\n            x ++; y ++;\n        }\n        arrays.push(temp);\n\n        temp = [];\n        x = i; y = 0;\n        while (x < row && y >= 0) {\n            temp.push(bitmap[x][y]);\n            x ++; y --;\n        }\n        arrays.push(temp);\n    }\n\n    const results = arrays\n        .map(arr => checkRow(arr, winningCount))\n        .filter(x => x !== GameStatus.OnGoing);\n    if (results.length) return results[0];\n\n    if (bitmap.some(row => row.some(c => c === CellStatus.Blank))) return GameStatus.OnGoing;\n    return GameStatus.Tie;\n}\n\n\nexport function useBoardGame(row: number, column: number, winningCount: number, firstHand: boolean) {\n    const [seq, setSeq] = useState<number>(0);\n    const [moves, setMoves] = useState<IMove[]>([]);\n    // true -> player 1 is going to place next chess; false -> player 2\n    const [player, setPlayer] = useState<boolean>(firstHand);\n\n    const placeChess = useCallback((x: number, y: number) => {\n        setMoves(pre => [...pre, {\n            x, y, seq,\n            status: player ? CellStatus.Player1 : CellStatus.Player2,\n        }]);\n        setSeq(pre => pre + 1);\n        setPlayer(pre => !pre);\n\n        return moves;\n    }, [seq, player]);\n\n    const bitmap = useMemo<CellStatus[][]>(() => {\n        const ret = new Array(row)\n            .fill(0)\n            .map(_ => new Array(column).fill(CellStatus.Blank));\n        moves.forEach(({ x, y, status }) => {\n            if (x < 0 || y < 0 || x >= row || y >= column) {\n                console.error(`Invalid move: (${x}, ${y})`);\n                console.log(\"current moves:\", moves);\n            }\n            ret[x][y] = status;\n        });\n        return ret;\n    }, [moves, column, row]);\n\n    const gameStatus = useMemo<GameStatus>(\n        () => check(bitmap, row, column, winningCount),\n        [bitmap, row, column, winningCount],\n    );\n\n    const restart = useCallback(() => {\n        setSeq(0);\n        setMoves([]);\n        setPlayer(firstHand);\n    }, [firstHand]);\n\n    return { bitmap, placeChess, gameStatus, player, restart, seq };\n}\n","import React from \"react\";\n\n\nconst HEIGHT = window.innerHeight;\nconst WIDTH = window.innerWidth;\nconst BASE = HEIGHT < WIDTH ? HEIGHT : WIDTH;\nconst BOARD_SIZE = BASE * 0.6;\n\nconst RATE = Math.round(BOARD_SIZE / 15);\nconst OFFSET = Math.ceil((BOARD_SIZE - RATE * 14) * 0.5);\nconst RADIUS = RATE * 0.4;\n\n\nexport function init(canvas: HTMLCanvasElement | null) {\n    if (!canvas) {\n        console.error(\"Canvas is null\");\n        return;\n    }\n\n    canvas.width = BOARD_SIZE;\n    canvas.height = BOARD_SIZE;\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    for (let i = 0; i < 15; i++) {\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(OFFSET + i * RATE, OFFSET);\n        ctx.lineTo(OFFSET + i * RATE, BOARD_SIZE - OFFSET);\n        ctx.stroke();\n\n        ctx.moveTo(OFFSET, i * RATE + OFFSET);\n        ctx.lineTo(BOARD_SIZE - OFFSET, i * RATE + OFFSET);\n        ctx.stroke();\n    }\n}\n\nexport function draw(canvas: HTMLCanvasElement | null, x: number, y: number, turn: number) {\n    const ctx = canvas?.getContext('2d');\n    if (!ctx) {\n        console.error(\"Canvas context is null\");\n        return;\n    }\n\n    const x1 = x * RATE + OFFSET;\n    const y1 = y * RATE + OFFSET;\n\n    ctx.fillStyle = turn % 2 === 0 ? \"#000\" : \"#fff\";\n\n    ctx.beginPath();\n    ctx.arc(x1, y1, RADIUS, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = turn % 2 === 0 ? \" #fff\" : \" #000\";\n    ctx.font=\"20px sans-serif\";\n    const text = `${turn + 1}`;\n    const x2 = x1 - text.length * 10 + 8;\n    const y2 = y1 + 5;\n    ctx.fillText(text, x2, y2);\n};\n\n\nexport function click2Coordinates(e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n    const cx = e.clientX - OFFSET - (window.innerWidth- BOARD_SIZE) / 2;\n    const cy = e.clientY - OFFSET - (window.innerHeight- BOARD_SIZE) / 2;\n\n    const x = Math.round(cx / RATE), y = Math.round(cy / RATE);\n    return { x, y };\n}","import React, {\n    forwardRef, useCallback, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport { click2Coordinates, draw, init } from \"./canvasUtils\";\n\nconst ROW = 15;\nconst COL = 15;\nconst WINNING_COUNT = 5;\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const {\n        bitmap, placeChess, gameStatus, player, restart, seq\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        },\n        restart: () => {\n            restart();\n            init(canvasRef.current);\n        }\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap]);\n\n    useEffect(() => {\n        init(canvasRef.current);\n    }, []);\n\n    const onClick = useCallback((e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n        if (!enable) return;\n\n        const { x, y } = click2Coordinates(e);\n\n        if (bitmap[x][y] === CellStatus.Blank) {\n            draw(canvasRef.current, x, y, seq);\n            placeChess(x, y);\n        }\n    }, [seq, bitmap]);\n\n    return (\n        <div>\n            <canvas ref={canvasRef}\n                onClick={onClick}\n            />\n\n        </div>\n    );\n});\n","import { Move } from \"../interfaces/game.interfaces\";\n\nexport function findBestMove(board: number[][]): Move {\n    return negamax(board, 2, -1, -Infinity, Infinity);\n}\n\n\nexport const negamax = (\n    board: number[][],\n    depth: number,\n    color: number,\n    alpha: number,\n    beta: number\n): Move => {\n    let bestMove: Move = { x: -1, y: -1, score: -Infinity };\n\n    if (depth === 0 || isGameOver(board)) {\n        return { x: -1, y: -1, score: color * evaluateBoard(board) };\n    }\n\n    let moves = generateMoves(board);\n\n    for (let move of moves) {\n        board[move.x][move.y] = color;\n\n        const nextMove = negamax(board, depth - 1, -color, -beta, -alpha);\n        nextMove.score = -nextMove.score;\n\n        board[move.x][move.y] = 0; // Undo the move\n\n        if (nextMove.score > bestMove.score) {\n            bestMove = { x: move.x, y: move.y, score: nextMove.score };\n        }\n\n        alpha = Math.max(alpha, nextMove.score);\n        if (alpha >= beta) {\n            break; // Beta cutoff\n        }\n    }\n\n    return bestMove;\n};\n\n\n// Generate possible moves, ordered by proximity to the last moves\nconst generateMoves = (board: number[][]): Move[] => {\n    let moves: Move[] = [];\n\n    for (let x = 0; x < board.length; x++) {\n        for (let y = 0; y < board[x].length; y++) {\n            if (board[x][y] === 0 && hasAdjacent(board, x, y)) {\n                moves.push({ x, y, score: 0 });\n            }\n        }\n    }\n\n    // Optionally, sort moves by heuristic score to improve pruning\n    moves.sort((a, b) => evaluateMove(board, b) - evaluateMove(board, a));\n\n    return moves;\n};\n\n// Check if a move is adjacent to any occupied cell\nconst hasAdjacent = (board: number[][], x: number, y: number): boolean => {\n    const directions = [\n        [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, -1], [1, -1], [-1, 1]\n    ];\n\n    for (let [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < board.length && ny >= 0 && ny < board.length && board[nx][ny] !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// Heuristically evaluate a move\nconst evaluateMove = (board: number[][], move: Move): number => {\n    board[move.x][move.y] = 1; // Assume the AI plays here\n    const score = evaluateBoard(board);\n    board[move.x][move.y] = 0; // Undo the move\n    return score;\n};\n\nconst evaluateBoard = (board: number[][]): number => {\n    let score = 0;\n\n    // Check rows, columns, and diagonals for potential scores\n    score += evaluateLines(board);\n    score += evaluateLines(transpose(board));\n    score += evaluateDiagonals(board);\n    score += evaluateDiagonals(transpose(board));\n\n    return score;\n};\n\n// Helper function to transpose the board (rows become columns)\nconst transpose = (board: number[][]): number[][] => {\n    return board[0].map((_, colIndex) => board.map(row => row[colIndex]));\n};\n\n// Evaluate rows and columns\nconst evaluateLines = (board: number[][]): number => {\n    let score = 0;\n\n    for (let row of board) {\n        score += evaluateLine(row);\n    }\n\n    return score;\n};\n\n// Evaluate diagonals (both major and minor)\nconst evaluateDiagonals = (board: number[][]): number => {\n    let score = 0;\n    const size = board.length;\n\n    // Major diagonals\n    for (let i = -size + 1; i < size; i++) {\n        let majorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = x + i;\n            if (y >= 0 && y < size) {\n                majorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(majorDiagonal);\n    }\n\n    // Minor diagonals\n    for (let i = 0; i < 2 * size - 1; i++) {\n        let minorDiagonal = [];\n        for (let x = 0; x < size; x++) {\n            const y = i - x;\n            if (y >= 0 && y < size) {\n                minorDiagonal.push(board[x][y]);\n            }\n        }\n        score += evaluateLine(minorDiagonal);\n    }\n\n    return score;\n};\n\n// Evaluate a single line (row, column, or diagonal)\nconst evaluateLine = (line: number[]): number => {\n    let score = 0;\n\n    for (let i = 0; i < line.length - 4; i++) {\n        const segment = line.slice(i, i + 5);\n        score += evaluateSegment(segment);\n    }\n\n    return score;\n};\n\n// Evaluate a segment of 5 cells\nconst evaluateSegment = (segment: number[]): number => {\n    const countX = segment.filter(cell => cell === 1).length;\n    const countO = segment.filter(cell => cell === -1).length;\n\n    if (countX === 5) return 100000; // Win for X\n    if (countO === 5) return -100000; // Win for O\n    if (countX > 0 && countO > 0) return 0; // Blocked line\n    if (countX === 4) return 1000;\n    if (countO === 4) return -1000;\n    if (countX === 3) return 100;\n    if (countO === 3) return -100;\n    if (countX === 2) return 10;\n    if (countO === 2) return -10;\n\n    return 0;\n};\n\nconst isGameOver = (board: number[][]): boolean => {\n    return checkWinningCondition(board, 1) || checkWinningCondition(board, -1);\n};\n\n// Check if a player has won\nconst checkWinningCondition = (board: number[][], player: number): boolean => {\n    const size = board.length;\n\n    // Check rows, columns, and diagonals\n    for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n            if (\n                checkDirection(board, x, y, player, 1, 0) || // Check row\n                checkDirection(board, x, y, player, 0, 1) || // Check column\n            checkDirection(board, x, y, player, 1, 1) || // Check major diagonal\n        checkDirection(board, x, y, player, 1, -1)   // Check minor diagonal\n            ) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// Check a direction (e.g., row, column, diagonal) for a win\nfunction checkDirection(\n    board: number[][],\n    startX: number,\n    startY: number,\n    player: number,\n    deltaX: number,\n    deltaY: number\n): boolean {\n    const size = board.length;\n    let count = 0;\n\n    for (let i = 0; i < 5; i++) {\n        const x = startX + i * deltaX;\n        const y = startY + i * deltaY;\n\n        if (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === player) {\n            count++;\n        } else {\n            break;\n        }\n\n        if (count === 5) {\n            return true;\n        }\n    }\n\n    return false;\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { Button } from \"../../components/button\";\nimport { IResultRef, Result } from \"../../components/result\";\nimport { Board, IBoardRef } from \"./board\";\nimport { findBestMove } from \"../../algorithms/negmax\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\n\nexport const GomokuPage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 200);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        resultRef.current?.show(\"loading\");\n\n        const res = findBestMove(board);\n        console.log(res);\n        setTimeout(() => {\n            boardRef.current?.placeChess(res.x, res.y);\n            resultRef.current?.hide();\n        }, 500);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React, {\n    FunctionComponent, forwardRef, useEffect, useImperativeHandle,\n    useLayoutEffect, useMemo, useRef,\n} from \"react\"\nimport { GameStatus, CellStatus } from \"../../interfaces/game.interfaces\";\nimport { useBoardGame } from \"../../hooks/useBoardGame\";\nimport styled from \"styled-components\";\n\nconst ROW = 3;\nconst COL = 3;\nconst WINNING_COUNT = 3;\nconst SIZE = 20;\n\nconst EmptyCell = styled.td`\n    height: ${SIZE}vmin;\n    width: ${SIZE}vmin;\n    font-size: calc(${SIZE}vmin - 20px);\n    line-height: calc(${SIZE}vmin - 20px);\n    cursor: pointer;\n    text-align: center;\n`;\n\nconst Player1Cell = styled(EmptyCell)`\n    &:after {\n        content: \"⭕️\";\n    }\n`;\n\nconst Player2Cell = styled(EmptyCell)`\n    &:after {\n        content: \"❌\";\n    }\n`;\n\nconst Cell: FunctionComponent<{\n    status: CellStatus;\n    onClick: () => void;\n}> = ({ status, onClick }) => {\n    if (status === CellStatus.Blank) return <EmptyCell onClick={onClick} />\n\n    return status === CellStatus.Player1\n        ? <Player1Cell />\n        : <Player2Cell />;\n};\n\nexport interface IBoardRef {\n    placeChess: (x: number, y: number) => void;\n    restart: () => void;\n}\n\nexport interface IBoardProps {\n    onStatusChange: (status: GameStatus) => void;\n    onPlayerPlaced: (board: CellStatus[][]) => void;\n}\n\nconst Table = styled.table`\n    border-collapse: collapse;\n\n    td + td,\n    th + th { border-left: 2vmin solid #fff; }\n    tr + tr { border-top: 2vmin solid #fff; }\n`;\n\n\nexport const Board = forwardRef(({\n    onStatusChange,\n    onPlayerPlaced,\n}: IBoardProps, ref) => {\n    const boardRef = useRef(null);\n    const {\n        bitmap, placeChess, gameStatus, player, restart,\n    } = useBoardGame(ROW, COL, WINNING_COUNT, true);\n\n    const enable = useMemo<boolean>(\n        () => gameStatus === GameStatus.OnGoing,\n        [gameStatus]\n    );\n\n    const board = useMemo(() => bitmap.map((r, x) => (\n        <tr key={`row-${x}`}>\n            {\n                r.map((c, y) => (\n                    <Cell key={`cell-${x}-${y}`}\n                        status={c}\n                        onClick={() => enable && placeChess(x, y)}\n                    />\n                ))\n            }\n        </tr>\n    )), [bitmap, placeChess, enable]);\n\n    useImperativeHandle(ref, (): IBoardRef => ({\n        /** Place a chess by the position of (x, y) */\n        placeChess: (x: number, y: number) => placeChess(x, y),\n        restart: () => restart(),\n    }), [placeChess, restart]);\n\n    useLayoutEffect(() => {\n        if (gameStatus === GameStatus.OnGoing) return;\n        onStatusChange(gameStatus);\n    }, [gameStatus, onStatusChange]);\n\n    useEffect(() => {\n        if (player || gameStatus !== GameStatus.OnGoing) return;\n        onPlayerPlaced(bitmap);\n    }, [player, bitmap, gameStatus, onPlayerPlaced]);\n\n    return (\n        <Table ref={boardRef}>\n            <tbody>\n                {board}\n            </tbody>\n        </Table>\n    );\n});\n","// Define the board size\nconst SIZE = 3;\n\nexport function findBestMove(board: number[][]): { x: number, y: number, score: number } {\n    let bestScore = -Infinity;\n    let bestMove = { x: -1, y: -1, score: bestScore };\n\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) {\n                board[i][j] = -1; // AI makes a move\n                const score = minimax(board, 0, false);\n                board[i][j] = 0; // Undo the move\n\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestMove = { x: i, y: j, score: bestScore };\n                }\n            }\n        }\n    }\n\n    return bestMove;\n}\n\n// Minimax function to evaluate the board\nfunction minimax(board: number[][], depth: number, isMaximizing: boolean): number {\n    let score = evaluate(board);\n\n    if (score === 10) return score - depth;\n    if (score === -10) return score + depth;\n    if (isMovesLeft(board) === false) return 0;\n\n    if (isMaximizing) {\n        let bestScore = -Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = -1; // AI makes a move\n                    bestScore = Math.max(bestScore, minimax(board, depth + 1, false));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    } else {\n        let bestScore = Infinity;\n\n        for (let i = 0; i < SIZE; i++) {\n            for (let j = 0; j < SIZE; j++) {\n                if (board[i][j] === 0) {\n                    board[i][j] = 1; // Player makes a move\n                    bestScore = Math.min(bestScore, minimax(board, depth + 1, true));\n                    board[i][j] = 0; // Undo the move\n                }\n            }\n        }\n\n        return bestScore;\n    }\n}\n\nfunction evaluate(board: number[][]): number {\n    for (let row = 0; row < SIZE; row++) {\n        if (board[row][0] === board[row][1] && board[row][1] === board[row][2]) {\n            if (board[row][0] === -1) return 10;\n            else if (board[row][0] === 1) return -10;\n        }\n    }\n\n    for (let col = 0; col < SIZE; col++) {\n        if (board[0][col] === board[1][col] && board[1][col] === board[2][col]) {\n            if (board[0][col] === -1) return 10;\n            else if (board[0][col] === 1) return -10;\n        }\n    }\n\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        if (board[0][0] === -1) return 10;\n        else if (board[0][0] === 1) return -10;\n    }\n\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        if (board[0][2] === -1) return 10;\n        else if (board[0][2] === 1) return -10;\n    }\n\n    return 0;\n}\n\n// Function to check if there are any moves left\nfunction isMovesLeft(board: number[][]): boolean {\n    for (let i = 0; i < SIZE; i++) {\n        for (let j = 0; j < SIZE; j++) {\n            if (board[i][j] === 0) return true;\n        }\n    }\n    return false;\n}\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { Board, IBoardRef } from \"./board\";\nimport { CellStatus, GameStatus } from \"../../interfaces/game.interfaces\";\nimport { Page } from \"../../components/page\";\nimport { findBestMove } from \"../../algorithms/minmax\";\nimport { Button } from \"../../components/button\";\nimport styled from \"styled-components\";\nimport { IResultRef, Result } from \"../../components/result\";\n\n\nconst ActionBar = styled.section`\n    position: fixed;\n    bottom: 50px;\n    z-index: 1000;\n`;\n\nexport const TicTacToePage = () => {\n    const boardRef = useRef<IBoardRef>(null);\n    const resultRef = useRef<IResultRef>(null);\n\n    useEffect(() => {\n        resultRef.current?.hide();\n    });\n\n    const onStatusChange = useCallback((status: GameStatus) => {\n        if (status === GameStatus.OnGoing) return;\n        console.log(status);\n\n        setTimeout(() => {\n            resultRef.current?.show(status);\n        }, 400);\n    }, []);\n\n    const onPlayerPlaced = useCallback((board: CellStatus[][]) => {\n        const res = findBestMove(board);\n\n        boardRef.current?.placeChess(res.x, res.y);\n    }, []);\n\n\n    const onClickRestart = useCallback(() => {\n        boardRef.current?.restart();\n        resultRef.current?.hide();\n    }, []);\n\n    return (\n        <Page>\n            <Result ref={resultRef} />\n            <Board onPlayerPlaced={onPlayerPlaced} onStatusChange={onStatusChange} ref={boardRef} />\n\n            <ActionBar>\n                <Button onClick={onClickRestart}>Restart</Button>\n            </ActionBar>\n        </Page>\n    );\n};\n","import React from 'react';\nimport { createHashRouter, RouterProvider } from \"react-router-dom\";\nimport { HomePage, TicTacToePage, GomokuPage } from './pages';\nimport './App.css';\n\nconst router = createHashRouter([\n    {\n        path: \"/tic-tac-toe\",\n        element: <TicTacToePage />,\n    },\n    {\n        path: \"/gomoku\",\n        element: <GomokuPage />\n    },\n    {\n        path: \"/\",\n        element: <HomePage />\n    },\n]);\n\nexport const App = () => {\n    return (\n        <RouterProvider router={router} />\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport { App } from './App';\n\nconst root = ReactDOM.createRoot(\n    document.getElementById('root') as HTMLElement\n);\n\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n"],"sourceRoot":""}